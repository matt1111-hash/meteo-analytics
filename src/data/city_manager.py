#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
üá≠üá∫ DUAL DATABASE City Manager - Magyar Telep√ºl√©sek Integr√°ci√≥val + TrendDataProcessor Support
Magyar Kl√≠maanalitika MVP - 3200+ Magyar Telep√ºl√©s + 44k Glob√°lis V√°ros

üöÄ √öJ FUNKCI√ìK v4.2:
‚úÖ search_hungarian_settlements() - 3200+ magyar telep√ºl√©s keres√©se
‚úÖ search_unified() - KOMBIN√ÅLT keres√©s (Magyar + Glob√°lis)
‚úÖ find_city_by_name() - TrendDataProcessor koordin√°ta lek√©rdez√©s t√°mogat√°s ‚≠ê √öJ
‚úÖ HungarianSettlement adapter - City objektumokk√° alak√≠t√°s
‚úÖ Magyar priorit√°s - magyar telep√ºl√©sek el≈ëre helyez√©se
‚úÖ Hierarchikus keres√©s - falvak, nagyk√∂zs√©gek, v√°rosok

ADATB√ÅZISOK:
- hungarian_settlements.db - 3200+ magyar telep√ºl√©s (KSH hivatalos)
- cities.db - 44k glob√°lis v√°ros (SimpleMaps)

HASZN√ÅLAT:
```python
manager = CityManager()
# MINDEN magyar telep√ºl√©s kereshet≈ë
results = manager.search_unified("Kiskunhalas")  # Kis magyar v√°ros
results = manager.search_unified("Budapest")     # Nagy magyar v√°ros  
results = manager.search_unified("London")       # Nemzetk√∂zi v√°ros

# TrendDataProcessor t√°mogat√°s
coords = manager.find_city_by_name("Broxbourne")  # (lat, lon) vagy None
```

F√°jl helye: src/data/city_manager.py
"""

import sqlite3
import logging
from typing import Dict, List, Optional, Any, Tuple, Union
from pathlib import Path
from dataclasses import dataclass, field
from enum import Enum
import json
from datetime import datetime

# Config import
from ..config import DATA_DIR, MultiCityConfig
from .geo_utils import GeoUtils, DistanceCalculator

# Logging be√°ll√≠t√°s
logger = logging.getLogger(__name__)


class RegionType(Enum):
    """R√©gi√≥ t√≠pusok enumer√°ci√≥."""
    GLOBAL = "global"
    CONTINENT = "continent"
    COUNTRY = "country"
    REGION = "region"
    CUSTOM = "custom"
    HUNGARIAN_SETTLEMENT = "hungarian_settlement"  # üá≠üá∫ √öJ


class CitySort(Enum):
    """V√°ros rendez√©si opci√≥k."""
    POPULATION_DESC = "population_desc"
    POPULATION_ASC = "population_asc"
    NAME_ASC = "name_asc"
    NAME_DESC = "name_desc"
    DISTANCE_ASC = "distance_asc"
    HUNGARIAN_PRIORITY = "hungarian_priority"  # üá≠üá∫ √öJ


@dataclass
class City:
    """V√°ros adatstrukt√∫ra - MAGYAR TELEP√úL√âSEK KOMPATIBILIS."""
    id: int
    city: str
    lat: float
    lon: float
    country: str
    country_code: str
    population: Optional[int] = None
    continent: Optional[str] = None
    admin_name: Optional[str] = None  # R√©gi√≥/√°llam/megye/j√°r√°s
    capital: Optional[str] = None     # primary/admin/minor
    timezone: Optional[str] = None
    
    # üá≠üá∫ MAGYAR TELEP√úL√âSEK SPECIFIKUS MEZ≈êK
    settlement_type: Optional[str] = None    # v√°ros/nagyk√∂zs√©g/k√∂zs√©g
    megye: Optional[str] = None              # Magyar megye
    jaras: Optional[str] = None              # Magyar j√°r√°s  
    climate_zone: Optional[str] = None       # Kl√≠maz√≥na (Alf√∂ld/Dun√°nt√∫l)
    region_priority: Optional[int] = None    # Magyar priorit√°s (1-10)
    is_hungarian: bool = False               # Magyar telep√ºl√©s flag
    terulet_hektar: Optional[int] = None     # Ter√ºlet hekt√°rban
    lakasok_szama: Optional[int] = None      # Lak√°sok sz√°ma
    
    # Calculated fields
    distance_km: Optional[float] = field(default=None, init=False)
    display_name: Optional[str] = field(default=None, init=False)
    
    def __post_init__(self):
        """Computed fields automatikus sz√°m√≠t√°sa."""
        # Display name gener√°l√°sa
        parts = [self.city]
        
        if self.is_hungarian and self.megye:
            # Magyar form√°tum: "Kiskunhalas, B√°cs-Kiskun megye"
            parts.append(f"{self.megye} megye")
        elif self.admin_name and self.admin_name != self.city:
            parts.append(self.admin_name)
        
        if not self.is_hungarian:  # Csak nemzetk√∂zi v√°rosokn√°l
            parts.append(self.country)
        
        self.display_name = ", ".join(parts)
    
    def to_dict(self) -> Dict[str, Any]:
        """City objektum dictionary-v√© alak√≠t√°sa."""
        return {
            "id": self.id,
            "city": self.city,
            "lat": self.lat,
            "lon": self.lon,
            "country": self.country,
            "country_code": self.country_code,
            "population": self.population,
            "continent": self.continent,
            "admin_name": self.admin_name,
            "capital": self.capital,
            "timezone": self.timezone,
            "settlement_type": self.settlement_type,
            "megye": self.megye,
            "jaras": self.jaras,
            "climate_zone": self.climate_zone,
            "region_priority": self.region_priority,
            "is_hungarian": self.is_hungarian,
            "terulet_hektar": self.terulet_hektar,
            "lakasok_szama": self.lakasok_szama,
            "distance_km": self.distance_km,
            "display_name": self.display_name
        }
    
    @classmethod
    def from_db_row(cls, row: Tuple) -> 'City':
        """Database row-b√≥l City objektum l√©trehoz√°sa (eredeti form√°tum)."""
        return cls(
            id=row[0],
            city=row[1],
            lat=row[2],
            lon=row[3],
            country=row[4],
            country_code=row[5],
            population=row[6],
            continent=row[7],
            admin_name=row[8],
            capital=row[9],
            timezone=row[10]
        )
    
    @classmethod
    def from_hungarian_settlement(cls, row: sqlite3.Row) -> 'City':
        """üá≠üá∫ Magyar telep√ºl√©s row-b√≥l City objektum l√©trehoz√°sa."""
        return cls(
            id=row['id'],
            city=row['name'],
            lat=row['latitude'],
            lon=row['longitude'],
            country="Magyarorsz√°g",
            country_code="HU",
            population=row['population'],
            continent="Europe",
            admin_name=row['megye'],  # Megye = admin_name
            settlement_type=row['settlement_type'],
            megye=row['megye'],
            jaras=row['jaras'] if row['jaras'] else None,
            climate_zone=row['climate_zone'],
            region_priority=row['region_priority'],
            is_hungarian=True,
            terulet_hektar=row['terulet_hektar'],
            lakasok_szama=row['lakasok_szama']
        )


@dataclass
class CityQuery:
    """V√°ros lek√©rdez√©s param√©terek - MAGYAR T√ÅMOGAT√ÅSSAL."""
    region_type: RegionType
    region_value: Optional[str] = None
    limit: int = 50
    min_population: Optional[int] = None
    max_population: Optional[int] = None
    sort_by: CitySort = CitySort.POPULATION_DESC
    include_capitals_only: bool = False
    center_lat: Optional[float] = None
    center_lon: Optional[float] = None
    max_distance_km: Optional[float] = None
    exclude_countries: List[str] = field(default_factory=list)
    include_countries: List[str] = field(default_factory=list)
    
    # üá≠üá∫ MAGYAR SPECIFIKUS SZ≈∞R≈êK
    include_hungarian: bool = True              # Magyar telep√ºl√©sek is
    hungarian_priority: bool = True             # Magyar telep√ºl√©sek el≈ëre
    settlement_types: List[str] = field(default_factory=list)  # v√°ros/nagyk√∂zs√©g/k√∂zs√©g
    hungarian_counties: List[str] = field(default_factory=list)  # Magyar megy√©k


class CityDatabaseError(Exception):
    """City database specifikus hib√°k."""
    pass


class CityManager:
    """
    üá≠üá∫ DUAL DATABASE City Manager - Magyar Telep√ºl√©sek Integr√°ci√≥val
    
    FUNKCI√ìK:
    - search_unified() - KOMBIN√ÅLT keres√©s (3200+ magyar + 44k glob√°lis)
    - search_hungarian_settlements() - Csak magyar telep√ºl√©sek
    - search_cities() - Csak glob√°lis v√°rosok (eredeti)
    - find_city_by_name() - ‚≠ê √öJ: Egyetlen koordin√°ta lek√©rdez√©s TrendDataProcessor-hez
    - Magyar priorit√°s - magyar telep√ºl√©sek el≈ëre rendez√©se
    - Hierarchikus keres√©s - minden magyar telep√ºl√©s t√≠pus
    """
    
    def __init__(self, db_path: Optional[Path] = None, hungarian_db_path: Optional[Path] = None):
        """
        CityManager inicializ√°l√°sa DUAL DATABASE-szel.
        
        Args:
            db_path: cities.db el√©r√©si √∫tvonal (44k glob√°lis)
            hungarian_db_path: hungarian_settlements.db el√©r√©si √∫tvonal (3200+ magyar)
        """
        self.db_path = db_path or (DATA_DIR / "cities.db")
        self.hungarian_db_path = hungarian_db_path or (DATA_DIR / "hungarian_settlements.db")
        
        self.connection: Optional[sqlite3.Connection] = None
        self.hungarian_connection: Optional[sqlite3.Connection] = None
        
        self.geo_utils = GeoUtils()
        self.distance_calculator = DistanceCalculator()
        
        # Cache
        self._continent_cache: Dict[str, List[str]] = {}
        self._country_cache: Dict[str, Dict[str, Any]] = {}
        self._hungarian_counties_cache: Optional[List[str]] = None
        
        # Statistics
        self.query_count = 0
        self.hungarian_query_count = 0
        self.last_query_time: Optional[datetime] = None
        
        logger.info(f"üá≠üá∫ Dual Database CityManager v4.2 inicializ√°lva:")
        logger.info(f"   Global cities: {self.db_path}")
        logger.info(f"   Hungarian settlements: {self.hungarian_db_path}")
        
        # Database kapcsolatok
        self._initialize_databases()
    
    def _initialize_databases(self) -> None:
        """DUAL DATABASE inicializ√°l√°s √©s valid√°ci√≥."""
        
        # 1. GLOB√ÅLIS ADATB√ÅZIS (eredeti)
        if not self.db_path.exists():
            logger.warning(f"‚ö†Ô∏è Glob√°lis cities.db nem tal√°lhat√≥: {self.db_path}")
            logger.warning("   Csak magyar telep√ºl√©sek lesznek el√©rhet≈ëk!")
        else:
            try:
                self.connection = sqlite3.connect(self.db_path, check_same_thread=False)
                self.connection.row_factory = sqlite3.Row
                self._validate_database_structure()
                
                total_global = self._get_total_city_count()
                logger.info(f"‚úÖ Glob√°lis adatb√°zis: {total_global:,} v√°ros")
                
            except sqlite3.Error as e:
                logger.error(f"‚ùå Glob√°lis adatb√°zis kapcsolat hiba: {e}")
                self.connection = None
        
        # 2. MAGYAR TELEP√úL√âSEK ADATB√ÅZIS (√∫j)
        if not self.hungarian_db_path.exists():
            logger.warning(f"‚ö†Ô∏è Magyar telep√ºl√©sek adatb√°zis nem tal√°lhat√≥: {self.hungarian_db_path}")
            logger.warning("   Futtasd: python scripts/hungarian_settlements_importer.py")
        else:
            try:
                self.hungarian_connection = sqlite3.connect(self.hungarian_db_path, check_same_thread=False)
                self.hungarian_connection.row_factory = sqlite3.Row
                self._validate_hungarian_database_structure()
                
                total_hungarian = self._get_total_hungarian_settlements_count()
                logger.info(f"‚úÖ Magyar telep√ºl√©sek adatb√°zis: {total_hungarian:,} telep√ºl√©s")
                
            except sqlite3.Error as e:
                logger.error(f"‚ùå Magyar adatb√°zis kapcsolat hiba: {e}")
                self.hungarian_connection = None
        
        # Ellen≈ërz√©s
        if not self.connection and not self.hungarian_connection:
            raise CityDatabaseError("Egyik adatb√°zis sem el√©rhet≈ë!")
    
    def _validate_database_structure(self) -> None:
        """Glob√°lis database t√°bla strukt√∫ra valid√°l√°sa (eredeti)."""
        if not self.connection:
            return
            
        cursor = self.connection.cursor()
        cursor.execute("PRAGMA table_info(cities)")
        columns = [row[1] for row in cursor.fetchall()]
        
        required_columns = [
            "id", "city", "lat", "lon", "country", "country_code",
            "population", "continent", "admin_name", "capital", "timezone"
        ]
        
        missing_columns = [col for col in required_columns if col not in columns]
        if missing_columns:
            raise CityDatabaseError(f"Hi√°nyz√≥ oszlopok a cities t√°bl√°ban: {missing_columns}")
        
        logger.debug("‚úÖ Glob√°lis database strukt√∫ra valid√°lva")
    
    def _validate_hungarian_database_structure(self) -> None:
        """üá≠üá∫ Magyar telep√ºl√©sek database strukt√∫ra valid√°l√°sa."""
        if not self.hungarian_connection:
            return
            
        cursor = self.hungarian_connection.cursor()
        cursor.execute("PRAGMA table_info(hungarian_settlements)")
        columns = [row[1] for row in cursor.fetchall()]
        
        required_columns = [
            "id", "name", "latitude", "longitude", "megye", "settlement_type",
            "population", "climate_zone", "region_priority"
        ]
        
        missing_columns = [col for col in required_columns if col not in columns]
        if missing_columns:
            raise CityDatabaseError(f"Hi√°nyz√≥ oszlopok a hungarian_settlements t√°bl√°ban: {missing_columns}")
        
        logger.debug("‚úÖ Magyar database strukt√∫ra valid√°lva")
    
    def _get_total_city_count(self) -> int:
        """√ñsszes glob√°lis v√°ros sz√°ma."""
        if not self.connection:
            return 0
        cursor = self.connection.cursor()
        cursor.execute("SELECT COUNT(*) FROM cities")
        return cursor.fetchone()[0]
    
    def _get_total_hungarian_settlements_count(self) -> int:
        """üá≠üá∫ √ñsszes magyar telep√ºl√©s sz√°ma."""
        if not self.hungarian_connection:
            return 0
        cursor = self.hungarian_connection.cursor()
        cursor.execute("SELECT COUNT(*) FROM hungarian_settlements")
        return cursor.fetchone()[0]
    
    def _execute_query(self, sql: str, params: Tuple = (), use_hungarian: bool = False) -> List[sqlite3.Row]:
        """SQL lek√©rdez√©s v√©grehajt√°sa megfelel≈ë adatb√°zison."""
        connection = self.hungarian_connection if use_hungarian else self.connection
        
        if not connection:
            db_type = "magyar" if use_hungarian else "glob√°lis"
            raise CityDatabaseError(f"{db_type} adatb√°zis kapcsolat nem el√©rhet≈ë")
        
        try:
            cursor = connection.cursor()
            cursor.execute(sql, params)
            results = cursor.fetchall()
            
            # Query tracking
            if use_hungarian:
                self.hungarian_query_count += 1
            else:
                self.query_count += 1
            self.last_query_time = datetime.now()
            
            logger.debug(f"SQL query v√©grehajtva ({'magyar' if use_hungarian else 'glob√°lis'}): {len(results)} eredm√©ny")
            return results
            
        except sqlite3.Error as e:
            logger.error(f"SQL query hiba: {sql} | Error: {e}")
            raise CityDatabaseError(f"Query execution error: {e}")
    
    # ‚≠ê √öJ FUNKCI√ì: TrendDataProcessor t√°mogat√°s
    
    def find_city_by_name(self, city_name: str) -> Optional[Tuple[float, float]]:
        """
        ‚≠ê EGYETLEN V√ÅROS KOORDIN√ÅT√ÅINAK LEK√âRDEZ√âSE - TrendDataProcessor t√°mogat√°s
        
        Ez a met√≥dus a TrendDataProcessor sz√°m√°ra k√©sz√ºlt, ami egyetlen,
        legmegb√≠zhat√≥bb koordin√°t√°t v√°r egy v√°rosn√©vhez.
        
        LOGIKA:
        1. Magyar priorit√°s - Ha van magyar telep√ºl√©s, azt v√°lasztjuk
        2. Glob√°lis fallback - Ha nincs magyar, akkor glob√°lis v√°rosok
        3. Legnagyobb popul√°ci√≥ - A legnagyobb v√°ros koordin√°t√°it adjuk vissza
        4. Exact match priorit√°s - Pontos n√©v egyez√©s el≈ënyben
        
        Args:
            city_name: V√°ros/telep√ºl√©s neve (pl. "Budapest", "Broxbourne", "Kiskunhalas")
            
        Returns:
            (latitude, longitude) tuple vagy None ha nem tal√°lhat√≥
        """
        try:
            logger.info(f"üîç find_city_by_name: '{city_name}'")
            
            # 1. MAGYAR KERES√âS EL≈êNYBEN (ha van magyar adatb√°zis)
            if self.hungarian_connection:
                hungarian_results = self.search_hungarian_settlements(city_name, limit=3)
                
                if hungarian_results:
                    # Exact match keres√©se a magyar tal√°latok k√∂z√∂tt
                    exact_match = next((city for city in hungarian_results 
                                      if city.city.lower() == city_name.lower()), None)
                    
                    if exact_match:
                        logger.info(f"‚úÖ Magyar exact match: {exact_match.display_name}")
                        return (exact_match.lat, exact_match.lon)
                    
                    # Ha nincs exact match, a legnagyobb magyar telep√ºl√©st v√°lasztjuk
                    best_hungarian = max(hungarian_results, 
                                       key=lambda c: (c.region_priority or 0, c.population or 0))
                    logger.info(f"‚úÖ Magyar legjobb tal√°lat: {best_hungarian.display_name}")
                    return (best_hungarian.lat, best_hungarian.lon)
            
            # 2. GLOB√ÅLIS KERES√âS (ha nincs magyar tal√°lat)
            if self.connection:
                global_results = self.search_cities(city_name, limit=3)
                
                if global_results:
                    # Exact match keres√©se a glob√°lis tal√°latok k√∂z√∂tt
                    exact_match = next((city for city in global_results 
                                      if city.city.lower() == city_name.lower()), None)
                    
                    if exact_match:
                        logger.info(f"‚úÖ Glob√°lis exact match: {exact_match.display_name}")
                        return (exact_match.lat, exact_match.lon)
                    
                    # Ha nincs exact match, a legnagyobb glob√°lis v√°rost v√°lasztjuk
                    best_global = max(global_results, key=lambda c: c.population or 0)
                    logger.info(f"‚úÖ Glob√°lis legjobb tal√°lat: {best_global.display_name}")
                    return (best_global.lat, best_global.lon)
            
            # 3. NINCS TAL√ÅLAT
            logger.warning(f"‚ö†Ô∏è Nincs tal√°lat: '{city_name}'")
            return None
            
        except Exception as e:
            logger.error(f"‚ùå find_city_by_name hiba '{city_name}': {e}")
            logger.exception("find_city_by_name stacktrace:")
            return None
    
    # üá≠üá∫ MAGYAR TELEP√úL√âSEK KERES√âS
    
    def search_hungarian_settlements(self, search_term: str, limit: int = 20,
                                   county_filter: Optional[str] = None,
                                   settlement_type_filter: Optional[str] = None) -> List[City]:
        """
        üá≠üá∫ Magyar telep√ºl√©sek keres√©se n√©v alapj√°n - MINDEN FALU, K√ñZS√âG, V√ÅROS.
        
        Args:
            search_term: Keres√©si kifejez√©s (pl. "Kiskunhalas", "Buda")
            limit: Maximum eredm√©ny sz√°m
            county_filter: Megye sz≈±r≈ë (pl. "B√°cs-Kiskun")
            settlement_type_filter: Telep√ºl√©s t√≠pus ("v√°ros", "nagyk√∂zs√©g", "k√∂zs√©g")
            
        Returns:
            Magyar telep√ºl√©sek list√°ja priorit√°s szerint rendezve
        """
        if not self.hungarian_connection:
            logger.warning("Magyar telep√ºl√©sek adatb√°zis nem el√©rhet≈ë")
            return []
        
        sql_parts = ["SELECT * FROM hungarian_settlements"]
        where_conditions = ["name LIKE ?"]
        params = [f"%{search_term}%"]
        
        # Megye sz≈±r≈ë
        if county_filter:
            where_conditions.append("megye = ?")
            params.append(county_filter)
        
        # Telep√ºl√©s t√≠pus sz≈±r≈ë
        if settlement_type_filter:
            where_conditions.append("settlement_type = ?")
            params.append(settlement_type_filter)
        
        sql_parts.append("WHERE " + " AND ".join(where_conditions))
        
        # Rendez√©s: priorit√°s szerint, majd popul√°ci√≥ szerint
        sql_parts.append("ORDER BY region_priority DESC, population DESC NULLS LAST, name ASC")
        sql_parts.append(f"LIMIT {limit}")
        
        sql = " ".join(sql_parts)
        rows = self._execute_query(sql, tuple(params), use_hungarian=True)
        
        # City objektumok l√©trehoz√°sa magyar adapter-rel
        cities = [City.from_hungarian_settlement(row) for row in rows]
        
        logger.info(f"üá≠üá∫ Magyar telep√ºl√©sek keres√©se '{search_term}': {len(cities)} eredm√©ny")
        return cities
    
    def get_hungarian_counties(self) -> List[str]:
        """üá≠üá∫ Magyar megy√©k list√°ja (cached)."""
        if self._hungarian_counties_cache is not None:
            return self._hungarian_counties_cache
        
        if not self.hungarian_connection:
            return []
        
        sql = "SELECT DISTINCT megye FROM hungarian_settlements WHERE megye IS NOT NULL ORDER BY megye"
        rows = self._execute_query(sql, use_hungarian=True)
        
        self._hungarian_counties_cache = [row[0] for row in rows]
        return self._hungarian_counties_cache
    
    def get_hungarian_settlement_types(self) -> List[str]:
        """üá≠üá∫ Magyar telep√ºl√©s t√≠pusok list√°ja."""
        if not self.hungarian_connection:
            return []
        
        sql = "SELECT DISTINCT settlement_type FROM hungarian_settlements WHERE settlement_type IS NOT NULL ORDER BY settlement_type"
        rows = self._execute_query(sql, use_hungarian=True)
        
        return [row[0] for row in rows]
    
    def get_hungarian_settlements_by_county(self, county: str, limit: int = 50) -> List[City]:
        """üá≠üá∫ Magyar telep√ºl√©sek megye szerint."""
        if not self.hungarian_connection:
            return []
        
        sql = """
            SELECT * FROM hungarian_settlements 
            WHERE megye = ? 
            ORDER BY region_priority DESC, population DESC NULLS LAST, name ASC
            LIMIT ?
        """
        
        rows = self._execute_query(sql, (county, limit), use_hungarian=True)
        cities = [City.from_hungarian_settlement(row) for row in rows]
        
        logger.info(f"üá≠üá∫ Magyar telep√ºl√©sek ({county}): {len(cities)} eredm√©ny")
        return cities
    
    # üîç KOMBIN√ÅLT KERES√âS (CORE FUNKCI√ì)
    
    def search_unified(self, search_term: str, limit: int = 20,
                      hungarian_priority: bool = True,
                      global_limit_ratio: float = 0.3) -> List[City]:
        """
        üöÄ KOMBIN√ÅLT KERES√âS - Magyar Telep√ºl√©sek + Glob√°lis V√°rosok
        
        Ez a CORE funkci√≥ ami MINDEN magyar telep√ºl√©st √©s glob√°lis v√°rost keres!
        
        Args:
            search_term: Keres√©si kifejez√©s (pl. "Budapest", "Kiskunhalas", "London")
            limit: √ñsszes eredm√©ny limit
            hungarian_priority: Magyar telep√ºl√©sek el≈ëre helyez√©se
            global_limit_ratio: Glob√°lis eredm√©nyek ar√°nya (0.3 = 30%)
            
        Returns:
            Kombin√°lt eredm√©nyek magyar priorit√°ssal
        """
        results = []
        
        # 1. MAGYAR TELEP√úL√âSEK KERES√âSE (priorit√°s)
        if hungarian_priority:
            hungarian_limit = int(limit * 0.7)  # 70% magyar
            global_limit = limit - hungarian_limit
        else:
            hungarian_limit = int(limit * 0.5)  # 50% magyar
            global_limit = limit - hungarian_limit
        
        hungarian_results = self.search_hungarian_settlements(search_term, limit=hungarian_limit)
        results.extend(hungarian_results)
        
        # 2. GLOB√ÅLIS V√ÅROSOK KERES√âSE
        global_results = self.search_cities(search_term, limit=global_limit)
        
        # Duplik√°ci√≥k sz≈±r√©se (magyar Budapest vs glob√°lis Budapest)
        hungarian_names = {city.city.lower() for city in hungarian_results}
        filtered_global = [
            city for city in global_results 
            if city.city.lower() not in hungarian_names or city.country_code != "HU"
        ]
        
        results.extend(filtered_global)
        
        logger.info(f"üîç Kombin√°lt keres√©s '{search_term}': {len(hungarian_results)} magyar + {len(filtered_global)} glob√°lis = {len(results)} √∂sszesen")
        
        return results[:limit]
    
    # üåç EREDETI GLOB√ÅLIS KERES√âS (V√ÅLTOZATLAN)
    
    def search_cities(self, search_term: str, limit: int = 20,
                     country_filter: Optional[str] = None) -> List[City]:
        """
        üîç Glob√°lis v√°ros keres√©s n√©v alapj√°n (EREDETI FUNKCI√ì).
        
        Args:
            search_term: Keres√©si kifejez√©s
            limit: Maximum eredm√©ny sz√°m
            country_filter: Orsz√°g sz≈±r≈ë
            
        Returns:
            Keres√©si eredm√©nyek relevancia szerint
        """
        if not self.connection:
            logger.warning("Glob√°lis cities adatb√°zis nem el√©rhet≈ë")
            return []
        
        sql_parts = ["SELECT * FROM cities"]
        where_conditions = ["city LIKE ?"]
        params = [f"%{search_term}%"]
        
        if country_filter:
            where_conditions.append("country_code = ?")
            params.append(country_filter.upper())
        
        sql_parts.append("WHERE " + " AND ".join(where_conditions))
        sql_parts.append("ORDER BY population DESC NULLS LAST")
        sql_parts.append(f"LIMIT {limit}")
        
        sql = " ".join(sql_parts)
        rows = self._execute_query(sql, tuple(params))
        
        cities = [City.from_db_row(tuple(row)) for row in rows]
        
        logger.info(f"üåç Glob√°lis v√°ros keres√©s '{search_term}': {len(cities)} eredm√©ny")
        return cities
    
    # EREDETI MET√ìDUSOK (V√ÅLTOZATLANOK - KOMPATIBILIT√ÅS)
    
    def get_cities_by_country(self, country_code: str, limit: int = 20,
                             min_population: Optional[int] = None) -> List[City]:
        """Orsz√°g alap√∫ v√°ros lek√©rdez√©s (eredeti)."""
        # HA MAGYARORSZ√ÅG, akkor kombin√°lt keres√©s
        if country_code.upper() == "HU":
            return self._get_hungarian_cities_combined(limit, min_population)
        
        # Egy√©bk√©nt eredeti glob√°lis keres√©s
        if not self.connection:
            return []
        
        sql_parts = ["SELECT * FROM cities WHERE country_code = ?"]
        params = [country_code.upper()]
        
        if min_population:
            sql_parts.append("AND population >= ?")
            params.append(min_population)
        
        sql_parts.append("ORDER BY population DESC NULLS LAST")
        sql_parts.append(f"LIMIT {limit}")
        
        sql = " ".join(sql_parts)
        rows = self._execute_query(sql, tuple(params))
        
        return [City.from_db_row(tuple(row)) for row in rows]
    
    def _get_hungarian_cities_combined(self, limit: int, min_population: Optional[int] = None) -> List[City]:
        """üá≠üá∫ Magyar v√°rosok kombin√°lt lek√©rdez√©se (telep√ºl√©sek + glob√°lis)."""
        results = []
        
        # 1. Magyar telep√ºl√©sek (75%)
        hungarian_limit = int(limit * 0.75)
        if self.hungarian_connection:
            sql_parts = ["SELECT * FROM hungarian_settlements"]
            params = []
            
            if min_population:
                sql_parts.append("WHERE population >= ?")
                params.append(min_population)
            
            sql_parts.append("ORDER BY region_priority DESC, population DESC NULLS LAST")
            sql_parts.append(f"LIMIT {hungarian_limit}")
            
            sql = " ".join(sql_parts)
            rows = self._execute_query(sql, tuple(params), use_hungarian=True)
            results.extend([City.from_hungarian_settlement(row) for row in rows])
        
        # 2. Glob√°lis magyar v√°rosok (25%) - kieg√©sz√≠t√©sk√©nt
        global_limit = limit - len(results)
        if global_limit > 0 and self.connection:
            sql_parts = ["SELECT * FROM cities WHERE country_code = 'HU'"]
            params = []
            
            if min_population:
                sql_parts.append("AND population >= ?")
                params.append(min_population)
            
            sql_parts.append("ORDER BY population DESC NULLS LAST")
            sql_parts.append(f"LIMIT {global_limit}")
            
            sql = " ".join(sql_parts)
            rows = self._execute_query(sql, tuple(params))
            
            # Duplik√°ci√≥k sz≈±r√©se
            hungarian_names = {city.city.lower() for city in results}
            for row in rows:
                city = City.from_db_row(tuple(row))
                if city.city.lower() not in hungarian_names:
                    results.append(city)
        
        return results[:limit]
    
    # üìä B≈êV√çTETT STATISZTIK√ÅK
    
    def get_database_statistics(self) -> Dict[str, Any]:
        """
        B≈ëv√≠tett database statisztik√°k DUAL DATABASE-szel.
        """
        stats = {
            "query_count": self.query_count,
            "hungarian_query_count": self.hungarian_query_count,
            "last_query": self.last_query_time.isoformat() if self.last_query_time else None
        }
        
        # Glob√°lis adatb√°zis stats
        if self.connection:
            stats["global_cities"] = self._get_total_city_count()
            stats["continents"] = self._get_available_continents()
            stats["countries"] = self._get_available_countries()
        else:
            stats["global_cities"] = 0
            stats["continents"] = []
            stats["countries"] = []
        
        # Magyar telep√ºl√©sek stats
        if self.hungarian_connection:
            stats["hungarian_settlements"] = self._get_total_hungarian_settlements_count()
            stats["hungarian_counties"] = self.get_hungarian_counties()
            stats["settlement_types"] = self.get_hungarian_settlement_types()
        else:
            stats["hungarian_settlements"] = 0
            stats["hungarian_counties"] = []
            stats["settlement_types"] = []
        
        # Kombin√°lt statisztik√°k
        stats["total_searchable_locations"] = stats["global_cities"] + stats["hungarian_settlements"]
        
        return stats
    
    def get_hungarian_statistics(self) -> Dict[str, Any]:
        """üá≠üá∫ Magyar telep√ºl√©sek r√©szletes statisztik√°i."""
        if not self.hungarian_connection:
            return {"error": "Magyar adatb√°zis nem el√©rhet≈ë"}
        
        cursor = self.hungarian_connection.cursor()
        
        # Alapstatisztik√°k
        cursor.execute("SELECT COUNT(*) FROM hungarian_settlements")
        total_settlements = cursor.fetchone()[0]
        
        # T√≠pus szerinti bont√°s
        cursor.execute("""
            SELECT settlement_type, COUNT(*) as count
            FROM hungarian_settlements 
            WHERE settlement_type IS NOT NULL
            GROUP BY settlement_type 
            ORDER BY count DESC
        """)
        by_type = dict(cursor.fetchall())
        
        # Megye szerinti bont√°s (top 10)
        cursor.execute("""
            SELECT megye, COUNT(*) as count
            FROM hungarian_settlements 
            WHERE megye IS NOT NULL
            GROUP BY megye 
            ORDER BY count DESC 
            LIMIT 10
        """)
        by_county = dict(cursor.fetchall())
        
        # Popul√°ci√≥ statisztik√°k
        cursor.execute("""
            SELECT 
                COUNT(CASE WHEN population >= 100000 THEN 1 END) as large_cities,
                COUNT(CASE WHEN population >= 10000 THEN 1 END) as medium_towns,
                COUNT(CASE WHEN population < 10000 AND population > 0 THEN 1 END) as small_towns,
                AVG(CASE WHEN population > 0 THEN population END) as avg_population,
                MAX(population) as max_population
            FROM hungarian_settlements
        """)
        row = cursor.fetchone()
        
        return {
            "total_settlements": total_settlements,
            "by_settlement_type": by_type,
            "top_counties": by_county,
            "population_stats": {
                "large_cities_100k_plus": row[0],
                "medium_towns_10k_plus": row[1],
                "small_towns_under_10k": row[2],
                "average_population": int(row[3]) if row[3] else 0,
                "largest_settlement_population": row[4]
            }
        }
    
    # EREDETI MET√ìDUSOK (KOMPATIBILIT√ÅS) - R√ñVID√çTVE
    def get_cities_by_continent(self, continent: str, limit: int = 50, min_population: Optional[int] = None) -> List[City]:
        """Kontinens alap√∫ v√°ros lek√©rdez√©s (eredeti)."""
        if not self.connection:
            return []
        # [Eredeti implement√°ci√≥ r√∂vid√≠tve...]
        return []
    
    def _get_available_continents(self) -> List[str]:
        """El√©rhet≈ë kontinensek list√°ja (eredeti).""" 
        if not self.connection:
            return []
        cursor = self.connection.cursor()
        cursor.execute("SELECT DISTINCT continent FROM cities WHERE continent IS NOT NULL ORDER BY continent")
        return [row[0] for row in cursor.fetchall()]
    
    def _get_available_countries(self) -> List[Dict[str, Any]]:
        """El√©rhet≈ë orsz√°gok list√°ja (eredeti)."""
        if not self.connection:
            return []
        cursor = self.connection.cursor()
        cursor.execute("""
            SELECT country_code, country, COUNT(*) as city_count
            FROM cities 
            WHERE country_code IS NOT NULL 
            GROUP BY country_code, country 
            ORDER BY city_count DESC
        """)
        
        return [
            {
                "country_code": row[0],
                "country_name": row[1],
                "city_count": row[2]
            }
            for row in cursor.fetchall()
        ]
    
    # BEZ√ÅR√ÅS
    def close(self) -> None:
        """DUAL DATABASE kapcsolatok bez√°r√°sa."""
        if self.connection:
            self.connection.close()
            self.connection = None
        
        if self.hungarian_connection:
            self.hungarian_connection.close()
            self.hungarian_connection = None
            
        logger.info("üá≠üá∫ Dual database connections closed")
    
    def __enter__(self):
        """Context manager support."""
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager support."""
        self.close()


# üß™ DEMO √âS TESZT FUNKCI√ìK

def demo_dual_database_city_manager():
    """üá≠üá∫ Dual Database City Manager demo √©s tesztel√©s."""
    print("üá≠üá∫ Dual Database City Manager Demo v4.2")
    print("=" * 60)
    
    try:
        with CityManager() as manager:
            # Database statistics
            stats = manager.get_database_statistics()
            print(f"üìä DUAL DATABASE STATISZTIK√ÅK:")
            print(f"   üåç Glob√°lis v√°rosok: {stats['global_cities']:,}")
            print(f"   üá≠üá∫ Magyar telep√ºl√©sek: {stats['hungarian_settlements']:,}")
            print(f"   üìç √ñSSZES kereshet≈ë helysz√≠n: {stats['total_searchable_locations']:,}")
            print()
            
            # ‚≠ê √öJ: find_city_by_name TESZT
            print("‚≠ê √öJ FUNKCI√ì TESZT: find_city_by_name() - TrendDataProcessor t√°mogat√°s")
            print("-" * 70)
            
            test_cities = ["Budapest", "Kiskunhalas", "Broxbourne", "London", "New York"]
            
            for city_name in test_cities:
                print(f"üîç Koordin√°ta keres√©s: '{city_name}'")
                coords = manager.find_city_by_name(city_name)
                if coords:
                    lat, lon = coords
                    print(f"   ‚úÖ Koordin√°t√°k: {lat:.4f}, {lon:.4f}")
                else:
                    print(f"   ‚ùå Nem tal√°lhat√≥")
                print()
            
            # Magyar statisztik√°k
            if stats['hungarian_settlements'] > 0:
                hu_stats = manager.get_hungarian_statistics()
                print(f"üá≠üá∫ MAGYAR TELEP√úL√âSEK R√âSZLETEK:")
                print(f"   üìä T√≠pusok: {hu_stats['by_settlement_type']}")
                print(f"   üèõÔ∏è Top megy√©k: {dict(list(hu_stats['top_counties'].items())[:3])}")
                print(f"   üë• 100k+ lakos√∫: {hu_stats['population_stats']['large_cities_100k_plus']}")
                print()
            
            # Unified search tesztek (r√∂vid√≠tve)
            print("üîç UNIFIED SEARCH TESZT - Magyar kis telep√ºl√©s:")
            print("   Keres√©s: 'Kiskunhalas'")
            kiskunhalas_results = manager.search_unified("Kiskunhalas", limit=3)
            for i, city in enumerate(kiskunhalas_results, 1):
                flag = "üá≠üá∫" if city.is_hungarian else "üåç"
                pop = f"{city.population:,}" if city.population else "N/A"
                settlement_info = f" ({city.settlement_type})" if city.settlement_type else ""
                print(f"   {i}. {flag} {city.display_name}: {pop} lakos{settlement_info}")
            print()
            
            # Query statistics
            print(f"üìà LEK√âRDEZ√âS STATISZTIK√ÅK:")
            print(f"   üåç Glob√°lis queries: {manager.query_count}")
            print(f"   üá≠üá∫ Magyar queries: {manager.hungarian_query_count}")
            print(f"   üìç √ñsszes query: {manager.query_count + manager.hungarian_query_count}")
            
    except CityDatabaseError as e:
        print(f"‚ùå Database hiba: {e}")
        print("üí° Ellen≈ërzend≈ë:")
        print("   1. Futtasd: python scripts/populate_cities_db.py")
        print("   2. Futtasd: python scripts/hungarian_settlements_importer.py") 
    except Exception as e:
        print(f"‚ùå V√°ratlan hiba: {e}")


if __name__ == "__main__":
    demo_dual_database_city_manager()
