#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Global Weather Analyzer - Application Controller - CLEAN ARCHITECTURE REFACTOR
Alkalmaz√°s k√∂zponti logikai vez√©rl≈ëje - REFAKTOR√ÅLT MVC ARCHITEKT√öR√ÅVAL.

üéØ CLEAN ARCHITECTURE FUNKCI√ìK:
‚úÖ K√∂zponti analysis request handling
‚úÖ Worker lifecycle management (AnalysisWorker + eredeti workerek)  
‚úÖ Clean signal orchestration (UI ‚Üî Controller ‚Üî Workers)
‚úÖ Provider routing integration
‚úÖ Wind gusts t√°mogat√°s minden analysis t√≠pusban
‚úÖ Interrupt/Cancel t√°mogat√°s minden workern√©l
üîß KOORDIN√ÅTA KULCSOK KOMPATIBILIT√ÅS JAV√çT√ÅS: lat/lon √âS latitude/longitude t√°mogat√°s
üå™Ô∏è KRITIKUS JAV√çT√ÅS: SZ√âLSEBESS√âG ADATOK FELDOLGOZ√ÅSA
üåπ SZ√âLIR√ÅNY KOMPATIBILIT√ÅSI FIX: winddirection_10m_dominant ‚Üí wind_direction_10m_dominant
"""

from typing import Optional, Dict, Any, List
from datetime import datetime, timedelta
import sqlite3
from pathlib import Path
import pandas as pd
import logging

from PySide6.QtCore import QObject, Signal, Slot, QTimer

from ..config import DATA_DIR, APIConfig, ProviderConfig, UserPreferences, UsageTracker
from .workers.data_fetch_worker import WorkerManager, GeocodingWorker, WeatherDataWorker
from .workers.analysis_worker import AnalysisWorker


class AppController(QObject):
    """
    üéØ CLEAN ARCHITECTURE CONTROLLER - K√∂zponti logikai agy
    
    FELEL≈êSS√âGEK:
    - Analysis request routing (single/multi-city/county)
    - Worker lifecycle management (create/start/stop/cleanup)
    - Provider selection √©s fallback strategies
    - Signal orchestration (UI ‚Üî Controller ‚Üî Analytics)
    - State management (current selections, active workers)
    
    üåê PROVIDER ROUTING FUNKCI√ìK:
    ‚úÖ Smart provider selection (Open-Meteo vs Meteostat)
    ‚úÖ User preference override support
    ‚úÖ Usage tracking √©s cost monitoring
    ‚úÖ Provider fallback strategies
    ‚úÖ Wind gusts t√°mogat√°s minden providern√©l
    
    üîß KOORDIN√ÅTA KULCSOK KOMPATIBILIT√ÅS:
    ‚úÖ 'lat'/'lon' √âS 'latitude'/'longitude' kulcsok t√°mogat√°sa
    ‚úÖ ControlPanel ‚Üî AppController kompatibilit√°s jav√≠tva
    
    üå™Ô∏è SZ√âLSEBESS√âG KRITIKUS JAV√çT√ÅS:
    ‚úÖ windspeed_10m_max adatok explicit m√°sol√°sa
    ‚úÖ Napi adatok structured processing
    ‚úÖ Teljes sz√©ladat kompatibilit√°s (speed + gusts)
    
    üåπ SZ√âLIR√ÅNY KOMPATIBILIT√ÅSI FIX:
    ‚úÖ winddirection_10m_dominant ‚Üí wind_direction_10m_dominant mapping
    ‚úÖ WindRoseChart kompatibilit√°s biztos√≠tva
    """
    
    # === CLEAN ARCHITECTURE SIGNALS ===
    
    # Analysis lifecycle signalok
    analysis_started = Signal(str)              # analysis_type
    analysis_progress = Signal(str, int)        # message, percentage
    analysis_completed = Signal(dict)           # result_data
    analysis_failed = Signal(str)               # error_message
    analysis_cancelled = Signal()               # megszak√≠t√°s meger≈ës√≠t√©se
    
    # Eredeti signalok meg≈ërz√©se (backwards compatibility)
    geocoding_results_ready = Signal(list)      # List[Dict] - telep√ºl√©s tal√°latok
    weather_data_ready = Signal(dict)           # Dict - API v√°lasz adatok
    error_occurred = Signal(str)                # str - hiba√ºzenet
    status_updated = Signal(str)                # str - st√°tusz √ºzenet
    progress_updated = Signal(str, int)         # worker_type, progress
    
    # Adatb√°zis m≈±veletek eredm√©nyei
    city_saved_to_db = Signal(dict)             # Dict - elmentett telep√ºl√©s adatok
    weather_saved_to_db = Signal(bool)          # bool - sikeres ment√©s
    
    # üåê PROVIDER ROUTING SIGNALOK
    provider_selected = Signal(str)             # str - v√°lasztott provider neve
    provider_usage_updated = Signal(dict)       # Dict - usage statistics
    provider_warning = Signal(str, int)         # provider_name, usage_percent
    provider_fallback = Signal(str, str)        # from_provider, to_provider
    
    def __init__(self, parent: Optional[QObject] = None):
        """Controller inicializ√°l√°sa CLEAN ARCHITECTURE t√°mogat√°ssal."""
        super().__init__(parent)
        
        self._logger = logging.getLogger(__name__)
        self._logger.info("üéØ AppController __init__ started (CLEAN ARCHITECTURE)")
        
        # === CLEAN ARCHITECTURE STATE ===
        self.current_city_data: Optional[Dict[str, Any]] = None
        self.current_weather_data: Optional[Dict[str, Any]] = None
        self.active_search_query: Optional[str] = None
        
        # üéØ ANALYSIS WORKER MANAGEMENT
        self.active_analysis_worker: Optional[AnalysisWorker] = None
        self.analysis_state = {
            'is_running': False,
            'analysis_type': None,
            'start_time': None,
            'request_data': None
        }
        
        # üåê PROVIDER ROUTING KOMPONENSEK (meg≈ërizve)
        self.provider_config = ProviderConfig()
        self.user_preferences = UserPreferences()
        self.usage_tracker = UsageTracker()
        
        self._logger.info("üåê Provider routing komponensek bet√∂ltve:")
        self._logger.info(f"üåê - Default provider: {self.user_preferences.get_selected_provider()}")
        self._logger.info(f"üåê - Available providers: {list(self.provider_config.PROVIDERS.keys())}")
        
        # WorkerManager k√∂zponti haszn√°lata (meg≈ërizve)
        self.worker_manager = WorkerManager()
        self._logger.info("üåê WorkerManager created with PROVIDER ROUTING support")
        
        # Adatb√°zis kapcsolat inicializ√°l√°sa
        self.db_path = DATA_DIR / "meteo_data.db"
        self._init_database_connection()
        
        # Signal kapcsol√°sok
        self._connect_worker_signals()
        self._connect_analysis_worker_signals()
        
        # Provider preferences bet√∂lt√©se
        self._load_user_preferences()
        
        self._logger.info("‚úÖ AppController inicializ√°lva (CLEAN ARCHITECTURE)")
    
    def _connect_analysis_worker_signals(self) -> None:
        """üéØ ANALYSIS WORKER signal bek√∂t√©sek."""
        self._logger.info("üîó Analysis worker signals kapcsol√°sa...")
        
        # Megjegyz√©s: Az AnalysisWorker signalok dinamikusan ker√ºlnek bek√∂t√©sre
        # amikor egy √∫j worker l√©trej√∂n a handle_analysis_request met√≥dusban
        
        self._logger.info("‚úÖ Analysis worker signals el≈ëk√©sz√≠tve")
    
    # === üéØ CLEAN ARCHITECTURE - K√ñZPONTI ANALYSIS REQUEST HANDLER ===
    
    @Slot(dict)
    def handle_analysis_request(self, request_data: Dict[str, Any]) -> None:
        """
        üéØ K√ñZPONTI ELEMZ√âSI K√âR√âS KEZEL≈ê - Clean Architecture Pattern
        
        Ez a met√≥dus fogadja az √∂sszes elemz√©si k√©r√©st a ControlPanel-t≈ël
        √©s a megfelel≈ë worker-ben futtatja azt h√°tt√©rsz√°lon.
        
        Args:
            request_data (dict): Teljes elemz√©si k√©r√©s minden param√©terre:
                - analysis_type: 'single_location', 'multi_city', 'county_analysis'
                - location_data: {'lat': float, 'lon': float, 'name': str, ...}
                - date_range: {'start_date': str, 'end_date': str}
                - provider_settings: {'provider': str, 'api_config': dict}
                - analysis_config: egy√©b elemz√©si be√°ll√≠t√°sok
        """
        self._logger.info(f"üéØ ANALYSIS REQUEST received: {request_data.get('analysis_type', 'unknown')}")
        
        try:
            # === 1. AKTU√ÅLIS ANALYSIS LE√ÅLL√çT√ÅSA ===
            if self.analysis_state['is_running']:
                self._logger.info("üõë Aktu√°lis analysis le√°ll√≠t√°sa...")
                self.stop_current_analysis()
                
                # R√∂vid v√°rakoz√°s a tiszta le√°ll√°sra
                QTimer.singleShot(200, lambda: self._start_new_analysis(request_data))
                return
            
            # === 2. √öJ ANALYSIS AZONNALI IND√çT√ÅSA ===
            self._start_new_analysis(request_data)
            
        except Exception as e:
            self._logger.error(f"Analysis request hiba: {e}")
            self.analysis_failed.emit(f"Elemz√©si k√©r√©s hiba: {e}")
    
    def _start_new_analysis(self, request_data: Dict[str, Any]) -> None:
        """
        üéØ √öJ ANALYSIS IND√çT√ÅSA - Worker l√©trehoz√°s √©s konfigur√°l√°s
        
        Args:
            request_data: Elemz√©si k√©r√©s param√©terei
        """
        try:
            # === 1. REQUEST VALID√ÅL√ÅS ===
            if not self._validate_analysis_request(request_data):
                return
            
            analysis_type = request_data.get('analysis_type', 'unknown')
            
            # === 2. ANALYSIS STATE INICIALIZ√ÅL√ÅS ===
            self.analysis_state = {
                'is_running': True,
                'analysis_type': analysis_type,
                'start_time': datetime.now(),
                'request_data': request_data.copy()
            }
            
            # === 3. ANALYSIS WORKER L√âTREHOZ√ÅS ===
            self.active_analysis_worker = AnalysisWorker(parent=self)
            
            # === 4. WORKER SIGNAL BEK√ñT√âSEK ===
            self.active_analysis_worker.progress_updated.connect(self._on_analysis_progress)
            self.active_analysis_worker.analysis_completed.connect(self._on_analysis_completed)
            self.active_analysis_worker.analysis_failed.connect(self._on_analysis_failed)
            self.active_analysis_worker.analysis_cancelled.connect(self._on_analysis_cancelled)
            
            # === 5. PROVIDER ROUTING INTEGR√ÅCI√ì ===
            enhanced_request = self._enhance_request_with_provider_routing(request_data)
            
            # === 6. WORKER IND√çT√ÅS ===
            success = self.active_analysis_worker.start_analysis(enhanced_request)
            
            if success:
                # Ind√≠t√°s signalok
                self.analysis_started.emit(analysis_type)
                self.status_updated.emit(f"üéØ {analysis_type.replace('_', ' ').title()} elemz√©s ind√≠tva...")
                
                self._logger.info(f"‚úÖ Analysis worker elind√≠tva: {analysis_type}")
            else:
                self._logger.error("‚ùå Analysis worker ind√≠t√°s sikertelen")
                self.analysis_failed.emit("Worker ind√≠t√°si hiba")
                self._cleanup_analysis_state()
                
        except Exception as e:
            self._logger.error(f"Analysis ind√≠t√°si hiba: {e}")
            self.analysis_failed.emit(f"Elemz√©s ind√≠t√°si hiba: {e}")
            self._cleanup_analysis_state()
    
    def _validate_analysis_request(self, request_data: Dict[str, Any]) -> bool:
        """
        üîß KRITIKUS JAV√çT√ÅS: ANALYSIS REQUEST VALID√ÅL√ÅS - KOORDIN√ÅTA KULCSOK KOMPATIBILIT√ÅS
        
        Args:
            request_data: K√©r√©s adatok
            
        Returns:
            bool: Valid-e a k√©r√©s
        """
        try:
            # K√∂telez≈ë mez≈ëk ellen≈ërz√©se
            required_fields = ['analysis_type', 'date_range']
            for field in required_fields:
                if field not in request_data:
                    self.analysis_failed.emit(f"Hi√°nyz√≥ k√∂telez≈ë mez≈ë: {field}")
                    return False
            
            analysis_type = request_data.get('analysis_type')
            valid_types = ['single_location', 'multi_city', 'county_analysis']
            
            if analysis_type not in valid_types:
                self.analysis_failed.emit(f"√ârv√©nytelen elemz√©s t√≠pus: {analysis_type}")
                return False
            
            # D√°tum range valid√°l√°s
            date_range = request_data.get('date_range', {})
            if not date_range.get('start_date') or not date_range.get('end_date'):
                self.analysis_failed.emit("Hi√°nyz√≥ d√°tum tartom√°ny")
                return False
            
            # üîß KRITIKUS JAV√çT√ÅS: Lok√°ci√≥ valid√°l√°s KOORDIN√ÅTA KULCSOK KOMPATIBILIT√ÅSSAL
            if analysis_type == 'single_location':
                # ControlPanel t√∂bbf√©le form√°tumot k√ºldhet:
                # 1. Direkt koordin√°t√°k: "latitude", "longitude" 
                # 2. location_data objektumban: "lat", "lon" VAGY "latitude", "longitude"
                
                has_direct_coords = False
                has_location_data_coords = False
                
                # 1. Direkt koordin√°t√°k ellen≈ërz√©se (ControlPanel form√°tum)
                if 'latitude' in request_data and 'longitude' in request_data:
                    has_direct_coords = True
                    self._logger.info("üîß Found direct coordinates: latitude/longitude")
                elif 'lat' in request_data and 'lon' in request_data:
                    has_direct_coords = True
                    self._logger.info("üîß Found direct coordinates: lat/lon")
                
                # 2. location_data objektum ellen≈ërz√©se (AppController v√°rt form√°tum)
                location_data = request_data.get('location_data', {})
                if location_data:
                    # Mindk√©t koordin√°ta kulcs form√°tum t√°mogat√°sa
                    lat_keys = ['lat', 'latitude']
                    lon_keys = ['lon', 'longitude']
                    
                    has_lat = any(key in location_data for key in lat_keys)
                    has_lon = any(key in location_data for key in lon_keys)
                    
                    if has_lat and has_lon:
                        has_location_data_coords = True
                        self._logger.info("üîß Found location_data coordinates")
                
                # Koordin√°t√°k valid√°l√°sa
                if not (has_direct_coords or has_location_data_coords):
                    error_msg = "Hi√°nyz√≥ lok√°ci√≥ koordin√°t√°k"
                    self._logger.error(f"üîß COORDINATE VALIDATION FAILED: {error_msg}")
                    self._logger.error(f"üîß Request keys: {list(request_data.keys())}")
                    if location_data:
                        self._logger.error(f"üîß location_data keys: {list(location_data.keys())}")
                    
                    self.analysis_failed.emit(error_msg)
                    return False
                
                self._logger.info("‚úÖ Single location coordinates validation passed")
            
            elif analysis_type in ['multi_city', 'county_analysis']:
                if not request_data.get('region_name') and not request_data.get('county_name'):
                    self.analysis_failed.emit("Hi√°nyz√≥ r√©gi√≥ vagy megye n√©v")
                    return False
            
            self._logger.info(f"‚úÖ Analysis request validation OK: {analysis_type}")
            return True
            
        except Exception as e:
            self._logger.error(f"Request validation hiba: {e}")
            self.analysis_failed.emit(f"K√©r√©s valid√°l√°si hiba: {e}")
            return False
    
    def _enhance_request_with_provider_routing(self, request_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        üåê PROVIDER ROUTING INTEGR√ÅCI√ì - K√©r√©s gazdag√≠t√°sa provider inform√°ci√≥kkal
        
        Args:
            request_data: Eredeti k√©r√©s
            
        Returns:
            Gazdag√≠tott k√©r√©s provider routing inform√°ci√≥kkal
        """
        try:
            enhanced_request = request_data.copy()
            
            # Koordin√°t√°k kinyer√©se az elemz√©s t√≠pusa alapj√°n
            latitude, longitude = self._extract_coordinates_from_request(request_data)
            
            if latitude is not None and longitude is not None:
                # Smart provider selection
                date_range = request_data.get('date_range', {})
                selected_provider = self._select_provider_for_request(
                    latitude, longitude, 
                    date_range.get('start_date', ''),
                    date_range.get('end_date', '')
                )
                
                # Provider inform√°ci√≥k hozz√°ad√°sa
                enhanced_request['selected_provider'] = selected_provider
                enhanced_request['provider_config'] = self.provider_config.PROVIDERS.get(selected_provider, {})
                
                # Usage tracking
                self._track_provider_usage(selected_provider)
                
                self._logger.info(f"üåê Provider routing: {selected_provider} selected")
            else:
                # Fallback provider
                enhanced_request['selected_provider'] = 'open-meteo'
                self._logger.warning("üåê No coordinates found, using fallback provider")
            
            return enhanced_request
            
        except Exception as e:
            self._logger.error(f"Provider routing enhancement hiba: {e}")
            return request_data  # Return original on error
    
    def _extract_coordinates_from_request(self, request_data: Dict[str, Any]) -> tuple[Optional[float], Optional[float]]:
        """
        üîß KOORDIN√ÅTA KULCSOK KOMPATIBILIT√ÅS: Koordin√°t√°k kinyer√©se a k√©r√©sb≈ël az elemz√©s t√≠pusa alapj√°n
        
        Args:
            request_data: K√©r√©s adatok
            
        Returns:
            (latitude, longitude) tuple vagy (None, None)
        """
        analysis_type = request_data.get('analysis_type')
        
        if analysis_type == 'single_location':
            # 1. Direkt koordin√°t√°k keres√©se (ControlPanel form√°tum)
            if 'latitude' in request_data and 'longitude' in request_data:
                return request_data.get('latitude'), request_data.get('longitude')
            elif 'lat' in request_data and 'lon' in request_data:
                return request_data.get('lat'), request_data.get('lon')
            
            # 2. location_data objektum ellen≈ërz√©se (AppController v√°rt form√°tum)
            location_data = request_data.get('location_data', {})
            if location_data:
                # Mindk√©t koordin√°ta kulcs form√°tum t√°mogat√°sa
                lat = location_data.get('latitude') or location_data.get('lat')
                lon = location_data.get('longitude') or location_data.get('lon')
                
                if lat is not None and lon is not None:
                    return lat, lon
        
        elif analysis_type in ['multi_city', 'county_analysis']:
            # Multi-city eset√©n haszn√°ljuk a jelenlegi v√°ros koordin√°t√°it (ha van)
            if self.current_city_data:
                return self.current_city_data.get('latitude'), self.current_city_data.get('longitude')
            
            # Vagy egy default magyar koordin√°ta
            return 47.4979, 19.0402  # Budapest
        
        return None, None
    
    # === üéØ ANALYSIS WORKER EVENT HANDLERS ===
    
    @Slot(str, int)
    def _on_analysis_progress(self, message: str, percentage: int):
        """Analysis progress friss√≠t√©se"""
        self.analysis_progress.emit(message, percentage)
        self.status_updated.emit(f"üìä {message} ({percentage}%)")
        
        self._logger.debug(f"üìä Analysis progress: {message} - {percentage}%")
    
    @Slot(dict)
    def _on_analysis_completed(self, result_data: dict):
        """Analysis befejez√©se sikeresen"""
        try:
            self._logger.info("‚úÖ Analysis completed successfully")
            
            # Eredm√©ny feldolgoz√°sa t√≠pus alapj√°n
            processed_result = self._process_analysis_result(result_data)
            
            # State cleanup
            analysis_type = self.analysis_state.get('analysis_type', 'unknown')
            duration = self._calculate_analysis_duration()
            
            # Success signalok
            self.analysis_completed.emit(processed_result)
            self.status_updated.emit(f"‚úÖ {analysis_type.replace('_', ' ').title()} elemz√©s befejezve ({duration:.1f}s)")
            
            # T√≠pus-specifikus eredm√©ny tov√°bb√≠t√°s (backwards compatibility)
            if analysis_type == 'single_location':
                self.weather_data_ready.emit(processed_result)
            elif analysis_type in ['multi_city', 'county_analysis']:
                # A MultiCityEngine eredm√©ny√©t tov√°bb√≠tjuk a megfelel≈ë GUI komponenseknek
                # Ez a MainWindow-ban fog megjelenni a t√©rk√©pen √©s az analytics n√©zetben
                pass
            
            # Cleanup
            self._cleanup_analysis_state()
            
        except Exception as e:
            self._logger.error(f"Analysis result processing hiba: {e}")
            self.analysis_failed.emit(f"Eredm√©ny feldolgoz√°si hiba: {e}")
    
    @Slot(str)
    def _on_analysis_failed(self, error_message: str):
        """Analysis hiba kezel√©se"""
        self._logger.error(f"‚ùå Analysis failed: {error_message}")
        
        self.analysis_failed.emit(error_message)
        self.status_updated.emit(f"‚ùå Elemz√©si hiba: {error_message}")
        
        self._cleanup_analysis_state()
    
    @Slot()
    def _on_analysis_cancelled(self):
        """Analysis megszak√≠t√°s kezel√©se"""
        self._logger.info("‚ÑπÔ∏è Analysis cancelled")
        
        self.analysis_cancelled.emit()
        self.status_updated.emit("‚ÑπÔ∏è Elemz√©s megszak√≠tva")
        
        self._cleanup_analysis_state()
    
    def _process_analysis_result(self, result_data: dict) -> dict:
        """
        Analysis eredm√©ny feldolgoz√°sa √©s struktur√°l√°sa
        
        Args:
            result_data: Nyers worker eredm√©ny
            
        Returns:
            Feldolgozott √©s struktur√°lt eredm√©ny
        """
        try:
            analysis_type = self.analysis_state.get('analysis_type', 'unknown')
            
            processed_result = {
                'analysis_type': analysis_type,
                'request_data': self.analysis_state.get('request_data', {}),
                'result_data': result_data.get('result_data', {}),
                'metadata': {
                    'provider': result_data.get('provider', 'unknown'),
                    'timestamp': result_data.get('timestamp'),
                    'duration': self._calculate_analysis_duration(),
                    'success': result_data.get('success', True)
                }
            }
            
            # T√≠pus-specifikus feldolgoz√°s
            if analysis_type == 'single_location':
                # Single location eredm√©ny tov√°bbi feldolgoz√°sa (ha sz√ºks√©ges)
                pass
            elif analysis_type in ['multi_city', 'county_analysis']:
                # Multi-city eredm√©ny tov√°bbi feldolgoz√°sa
                processed_result['city_count'] = len(result_data.get('result_data', {}).get('cities', []))
            
            return processed_result
            
        except Exception as e:
            self._logger.error(f"Result processing hiba: {e}")
            return result_data  # Return original on error
    
    def _calculate_analysis_duration(self) -> float:
        """Analysis id≈ëtartam sz√°m√≠t√°sa m√°sodpercben"""
        start_time = self.analysis_state.get('start_time')
        if start_time:
            return (datetime.now() - start_time).total_seconds()
        return 0.0
    
    def _cleanup_analysis_state(self):
        """Analysis state √©s worker cleanup"""
        try:
            # Worker cleanup
            if self.active_analysis_worker:
                if self.active_analysis_worker.isRunning():
                    self.active_analysis_worker.stop_analysis()
                
                # Disconnect signalok
                self.active_analysis_worker.progress_updated.disconnect()
                self.active_analysis_worker.analysis_completed.disconnect()
                self.active_analysis_worker.analysis_failed.disconnect()
                self.active_analysis_worker.analysis_cancelled.disconnect()
                
                # Worker t√∂rl√©se
                self.active_analysis_worker.deleteLater()
                self.active_analysis_worker = None
            
            # State reset
            self.analysis_state = {
                'is_running': False,
                'analysis_type': None,
                'start_time': None,
                'request_data': None
            }
            
            self._logger.info("üßπ Analysis state cleaned up")
            
        except Exception as e:
            self._logger.error(f"Cleanup hiba: {e}")
    
    # === üéØ ANALYSIS CONTROL METHODS ===
    
    def stop_current_analysis(self) -> None:
        """
        üõë AKTU√ÅLIS ANALYSIS LE√ÅLL√çT√ÅSA
        Graceful shutdown - nem brut√°lis termin√°l√°s
        """
        try:
            if not self.analysis_state['is_running']:
                self._logger.info("üõë Nincs fut√≥ analysis amit meg lehetne szak√≠tani")
                return
            
            analysis_type = self.analysis_state.get('analysis_type', 'unknown')
            self._logger.info(f"üõë Analysis megszak√≠t√°sa: {analysis_type}")
            
            if self.active_analysis_worker:
                self.active_analysis_worker.stop_analysis()
            
            # State update
            self.status_updated.emit("üõë Elemz√©s megszak√≠t√°sa...")
            
        except Exception as e:
            self._logger.error(f"Analysis stop hiba: {e}")
    
    def is_analysis_running(self) -> bool:
        """Analysis fut√°si √°llapot lek√©rdez√©se"""
        return self.analysis_state.get('is_running', False)
    
    def get_current_analysis_info(self) -> Dict[str, Any]:
        """Jelenlegi analysis inform√°ci√≥k lek√©rdez√©se"""
        return self.analysis_state.copy()
    
    # === EREDETI MET√ìDUSOK MEG≈êRZ√âSE (Backwards Compatibility) ===
    
    def _load_user_preferences(self) -> None:
        """User preferences bet√∂lt√©se √©s signalok k√ºld√©se."""
        try:
            selected_provider = self.user_preferences.get_selected_provider()
            self._logger.info(f"üåê User selected provider: {selected_provider}")
            
            # Provider selection signal
            self.provider_selected.emit(selected_provider)
            
            # Usage statistics signal
            usage_summary = self.usage_tracker.get_usage_summary()
            self.provider_usage_updated.emit({
                'meteostat': {
                    'requests': usage_summary.get('meteostat_requests', 0),
                    'limit': usage_summary.get('meteostat_limit', 10000)
                },
                'open-meteo': {
                    'requests': usage_summary.get('openmeteo_requests', 0),
                    'limit': float('inf')  # Unlimited
                }
            })
            
            # Warning ellen≈ërz√©s
            warning_level = usage_summary.get('warning_level', 'normal')
            usage_percent = usage_summary.get('meteostat_percentage', 0)
            
            if warning_level == 'critical':
                self.provider_warning.emit('meteostat', int(usage_percent))
            elif warning_level == 'warning':
                self.provider_warning.emit('meteostat', int(usage_percent))
            
            self._logger.info("‚úÖ User preferences bet√∂ltve √©s signalok elk√ºldve")
            
        except Exception as e:
            self._logger.error(f"User preferences bet√∂lt√©si hiba: {e}")
    
    def _init_database_connection(self) -> None:
        """üå™Ô∏è KRITIKUS JAV√çT√ÅS: Adatb√°zis kapcsolat inicializ√°l√°sa WIND GUSTS s√©ma friss√≠t√©ssel."""
        try:
            # Adatb√°zis mappa l√©trehoz√°sa ha nem l√©tezik
            self.db_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Kapcsolat tesztel√©se √©s s√©ma friss√≠t√©s
            conn = sqlite3.connect(str(self.db_path))
            
            # üå™Ô∏è KRITIKUS JAV√çT√ÅS: Adatb√°zis s√©ma friss√≠t√©s wind_gusts_max oszloppal
            self._update_database_schema(conn)
            
            conn.close()
            
            self._logger.info(f"‚úÖ Adatb√°zis kapcsolat OK (WIND GUSTS support): {self.db_path}")
            
        except Exception as e:
            self._logger.error(f"Adatb√°zis kapcsolat hiba: {e}")
            self.error_occurred.emit(f"Adatb√°zis hiba: {e}")
    
    def _update_database_schema(self, conn: sqlite3.Connection) -> None:
        """
        üå™Ô∏è KRITIKUS JAV√çT√ÅS: Adatb√°zis s√©ma friss√≠t√©s wind_gusts_max oszloppal.
        
        Args:
            conn: SQLite kapcsolat
        """
        try:
            cursor = conn.cursor()
            
            # Ellen≈ërizz√ºk, hogy l√©tezik-e a wind_gusts_max oszlop
            cursor.execute("PRAGMA table_info(weather_data)")
            columns = [column[1] for column in cursor.fetchall()]
            
            if 'wind_gusts_max' not in columns:
                self._logger.info("üå™Ô∏è wind_gusts_max oszlop nem l√©tezik - hozz√°ad√°s...")
                
                # √öj oszlop hozz√°ad√°sa
                cursor.execute("""
                    ALTER TABLE weather_data 
                    ADD COLUMN wind_gusts_max REAL
                """)
                
                self._logger.info("‚úÖ wind_gusts_max oszlop sikeresen hozz√°adva")
                
                # Index l√©trehoz√°sa a gyorsabb lek√©rdez√©sekhez
                cursor.execute("""
                    CREATE INDEX IF NOT EXISTS idx_weather_data_wind_gusts_max 
                    ON weather_data(wind_gusts_max)
                """)
                
                self._logger.info("‚úÖ wind_gusts_max index sikeresen l√©trehozva")
                
            else:
                self._logger.info("‚úÖ wind_gusts_max oszlop m√°r l√©tezik")
            
            # üåê Provider tracking oszlop hozz√°ad√°sa
            if 'data_provider' not in columns:
                self._logger.info("üåê data_provider oszlop nem l√©tezik - hozz√°ad√°s...")
                
                cursor.execute("""
                    ALTER TABLE weather_data 
                    ADD COLUMN data_provider TEXT DEFAULT 'open-meteo'
                """)
                
                self._logger.info("‚úÖ data_provider oszlop sikeresen hozz√°adva")
            
            conn.commit()
            
        except Exception as e:
            self._logger.error(f"Adatb√°zis s√©ma friss√≠t√©s hiba: {e}")
            # Nem kritikus hiba, folytatjuk a m≈±k√∂d√©st
    
    def _connect_worker_signals(self) -> None:
        """Worker signal kapcsol√°sok."""
        self._logger.info("üîó Worker signals kapcsol√°sa...")
        
        # Geocoding worker signalok
        self.worker_manager.geocoding_completed.connect(self._on_geocoding_completed)
        self._logger.info("üîó geocoding_completed signal connected")
        
        # Weather data worker signalok
        self.worker_manager.weather_data_completed.connect(self._on_weather_data_completed)
        self._logger.info("üîó weather_data_completed signal connected")
        
        # √Åltal√°nos worker signalok
        self.worker_manager.error_occurred.connect(self._on_worker_error)
        self.worker_manager.progress_updated.connect(self.progress_updated.emit)
        
        self._logger.info("‚úÖ Signal kapcsol√°sok k√©sz")
    
    # === PROVIDER ROUTING MET√ìDUSOK (MEG≈êRIZVE) ===
    
    def _select_provider_for_request(self, latitude: float, longitude: float, 
                                   start_date: str, end_date: str) -> str:
        """
        üåê Smart provider selection a k√©r√©s alapj√°n.
        
        Args:
            latitude: F√∂ldrajzi sz√©less√©g
            longitude: F√∂ldrajzi hossz√∫s√°g
            start_date: Kezd≈ë d√°tum
            end_date: Befejez≈ë d√°tum
            
        Returns:
            V√°lasztott provider neve
        """
        try:
            # User preference ellen≈ërz√©se
            user_provider = self.user_preferences.get_selected_provider()
            
            if user_provider != 'auto':
                self._logger.info(f"üåê User forced provider: {user_provider}")
                
                # Rate limiting ellen≈ërz√©s premium providerekn√©l
                if user_provider != 'open-meteo':
                    usage_summary = self.usage_tracker.get_usage_summary()
                    if usage_summary.get('warning_level') == 'critical':
                        self._logger.warning(f"‚ö†Ô∏è Provider {user_provider} rate limit exceeded, fallback to open-meteo")
                        self.provider_fallback.emit(user_provider, 'open-meteo')
                        return 'open-meteo'
                
                return user_provider
            
            # Automatikus provider routing
            self._logger.info("üåê Automatic provider routing...")
            
            # D√°tum tartom√°ny ellen≈ërz√©se
            start = datetime.strptime(start_date, "%Y-%m-%d")
            end = datetime.strptime(end_date, "%Y-%m-%d")
            days_requested = (end - start).days + 1
            
            # Historikus adat ellen≈ërz√©se (2 h√≥napn√°l r√©gebbi)
            historical_threshold = datetime.now() - timedelta(days=60)
            is_historical = start < historical_threshold
            
            # Nagy d√°tum tartom√°ny (3+ h√≥nap)
            is_large_request = days_requested > 90
            
            self._logger.info(f"üåê Request analysis:")
            self._logger.info(f"üåê - Days requested: {days_requested}")
            self._logger.info(f"üåê - Is historical: {is_historical}")
            self._logger.info(f"üåê - Is large request: {is_large_request}")
            
            # Smart routing logic
            if is_historical or is_large_request:
                # Meteostat jobb historikus adatokhoz
                usage_summary = self.usage_tracker.get_usage_summary()
                if usage_summary.get('warning_level') != 'critical':
                    self._logger.info("üåê Selected Meteostat for historical/large request")
                    return 'meteostat'
                else:
                    self._logger.info("üåê Meteostat rate limited, fallback to Open-Meteo")
                    self.provider_fallback.emit('meteostat', 'open-meteo')
                    return 'open-meteo'
            else:
                # Aktu√°lis/k√∂zelm√∫lt adatokhoz Open-Meteo
                self._logger.info("üåê Selected Open-Meteo for recent data")
                return 'open-meteo'
                
        except Exception as e:
            self._logger.error(f"Provider selection error: {e}")
            return 'open-meteo'  # Fallback to free provider
    
    def _track_provider_usage(self, provider_name: str) -> None:
        """
        Provider haszn√°lat tracking.
        
        Args:
            provider_name: Provider neve
        """
        try:
            # Usage tracking
            updated_usage = self.usage_tracker.track_request(provider_name)
            
            if updated_usage:
                self._logger.info(f"üåê Tracked usage for {provider_name}")
                
                # Usage statistics friss√≠t√©se - a track_request visszaadott adatok alapj√°n
                usage_summary = self.usage_tracker.get_usage_summary()
                self.provider_usage_updated.emit({
                    'meteostat': {
                        'requests': usage_summary.get('meteostat_requests', 0),
                        'limit': usage_summary.get('meteostat_limit', 10000)
                    },
                    'open-meteo': {
                        'requests': usage_summary.get('openmeteo_requests', 0),
                        'limit': float('inf')  # Unlimited
                    }
                })
                
                # Warning ellen≈ërz√©s
                if provider_name != 'open-meteo':
                    warning_level = usage_summary.get('warning_level', 'normal')
                    usage_percent = usage_summary.get('meteostat_percentage', 0)
                    
                    if warning_level == 'critical':
                        self._logger.critical(f"üö® Provider {provider_name} usage critical: {usage_percent:.1f}%")
                        self.provider_warning.emit(provider_name, int(usage_percent))
                    elif warning_level == 'warning':
                        self._logger.warning(f"‚ö†Ô∏è Provider {provider_name} usage warning: {usage_percent:.1f}%")
                        self.provider_warning.emit(provider_name, int(usage_percent))
            else:
                self._logger.warning(f"‚ö†Ô∏è Failed to track usage for {provider_name}")
                
        except Exception as e:
            self._logger.error(f"Usage tracking error: {e}")
    
    @Slot(str)
    def handle_provider_change(self, provider_name: str) -> None:
        """
        Provider v√°ltoz√°s kezel√©se GUI-b√≥l.
        
        Args:
            provider_name: √öj provider neve
        """
        try:
            self._logger.info(f"üåê Provider change request: {provider_name}")
            
            # User preferences friss√≠t√©se
            self.user_preferences.set_selected_provider(provider_name)
            
            # Provider selection signal
            self.provider_selected.emit(provider_name)
            
            # St√°tusz friss√≠t√©se
            if provider_name == 'auto':
                status_msg = "ü§ñ Automatikus provider routing bekapcsolva"
            else:
                provider_info = self.provider_config.PROVIDERS.get(provider_name, {})
                provider_display = provider_info.get('name', provider_name)
                status_msg = f"üåê Provider be√°ll√≠tva: {provider_display}"
            
            self.status_updated.emit(status_msg)
            
            self._logger.info(f"‚úÖ Provider changed to: {provider_name}")
            
        except Exception as e:
            self._logger.error(f"Provider change error: {e}")
            self.error_occurred.emit(f"Provider v√°lt√°si hiba: {e}")
    
    # === TELEP√úL√âS KERES√âS LOGIKA (MEG≈êRIZVE) ===
    
    @Slot(str)
    def handle_search_request(self, search_query: str) -> None:
        """
        Telep√ºl√©s keres√©si k√©r√©s kezel√©se a ControlPanel-t≈ël.
        
        Args:
            search_query: Keres√©si kifejez√©s
        """
        self._logger.info(f"üîç handle_search_request called with: '{search_query}'")
        
        # Alapszint≈± valid√°ci√≥
        if not search_query or len(search_query.strip()) < 2:
            error_msg = "Legal√°bb 2 karakter sz√ºks√©ges a keres√©shez"
            self._logger.error(f"Validation error: {error_msg}")
            self.error_occurred.emit(error_msg)
            return
        
        # Jelenlegi keres√©s t√°rol√°sa
        self.active_search_query = search_query.strip()
        self._logger.info(f"üîç Active search query set: '{self.active_search_query}'")
        
        # St√°tusz friss√≠t√©se
        search_info = f"Keres√©s: {self.active_search_query}"
        self.status_updated.emit(search_info + "...")
        self._logger.info(f"üîç Status updated: {search_info}")
        
        # Geocoding worker ind√≠t√°sa
        try:
            self._logger.info("üöÄ Creating GeocodingWorker...")
            worker = GeocodingWorker(self.active_search_query)
            self._logger.info(f"‚úÖ GeocodingWorker created for query: '{self.active_search_query}'")
            
            # WorkerManager k√∂zponti haszn√°lata
            self._logger.info("üöÄ Starting worker via WorkerManager...")
            worker_id = self.worker_manager.start_geocoding(worker)
            self._logger.info(f"‚úÖ GeocodingWorker started via WorkerManager with ID: {worker_id}")
            
        except Exception as e:
            error_msg = f"Geocoding worker ind√≠t√°si hiba: {e}"
            self._logger.error(error_msg)
            import traceback
            traceback.print_exc()
            self.error_occurred.emit(error_msg)
            return
        
        self._logger.info(f"‚úÖ handle_search_request completed successfully for '{search_query}'")
    
    @Slot(list)
    def _on_geocoding_completed(self, results: List[Dict[str, Any]]) -> None:
        """
        Geocoding befejez√©s√©nek kezel√©se.
        
        Args:
            results: Telep√ºl√©s tal√°latok list√°ja
        """
        self._logger.info(f"üîç _on_geocoding_completed called with {len(results)} results")
        
        try:
            if not results:
                msg = "Nem tal√°lhat√≥ telep√ºl√©s ezzel a n√©vvel"
                self._logger.info(f"üîç No results found")
                self.status_updated.emit(msg)
                self.geocoding_results_ready.emit([])
                return
            
            self._logger.info(f"üîç Processing {len(results)} geocoding results...")
            
            # Eredm√©nyek feldolgoz√°sa √©s gazdag√≠t√°sa
            processed_results = self._process_geocoding_results(results)
            self._logger.info(f"üîç Processed {len(processed_results)} results")
            
            # St√°tusz friss√≠t√©se
            status_msg = f"{len(processed_results)} telep√ºl√©s tal√°lat"
            self.status_updated.emit(status_msg)
            self._logger.info(f"üîç Status updated: {status_msg}")
            
            # Eredm√©nyek tov√°bb√≠t√°sa a GUI-nak
            self._logger.info(f"üì° Emitting geocoding_results_ready signal...")
            self.geocoding_results_ready.emit(processed_results)
            
            self._logger.info(f"‚úÖ Geocoding befejezve: {len(processed_results)} tal√°lat")
            
        except Exception as e:
            self._logger.error(f"Geocoding feldolgoz√°si hiba: {e}")
            import traceback
            traceback.print_exc()
            self.error_occurred.emit(f"Keres√©si eredm√©nyek feldolgoz√°si hiba: {e}")
    
    def _process_geocoding_results(self, raw_results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Geocoding eredm√©nyek feldolgoz√°sa √©s gazdag√≠t√°sa.
        
        Args:
            raw_results: Nyers API eredm√©nyek
            
        Returns:
            Feldolgozott √©s gazdag√≠tott eredm√©nyek
        """
        processed = []
        
        self._logger.info(f"üîç Processing {len(raw_results)} raw results")
        
        for i, result in enumerate(raw_results):
            try:
                # Alapadatok kinyer√©se
                processed_result = {
                    'name': result.get('name', ''),
                    'latitude': result.get('latitude', 0.0),
                    'longitude': result.get('longitude', 0.0),
                    'country': result.get('country', ''),
                    'admin1': result.get('admin1', ''),  # megye/r√©gi√≥
                    'admin2': result.get('admin2', ''),  # j√°r√°s
                    'population': result.get('population'),
                    'timezone': result.get('timezone', 'UTC'),
                    'elevation': result.get('elevation'),
                    
                    # Megjelen√≠t√©s a GUI sz√°m√°ra
                    'display_name': self._create_display_name(result),
                    'search_rank': result.get('rank', 999),
                    'original_query': self.active_search_query,
                }
                
                processed.append(processed_result)
                
                # Debug inform√°ci√≥ minden 5. eredm√©nyhez
                if i < 5 or i % 5 == 0:
                    name = processed_result['name']
                    country = processed_result['country']
                    self._logger.debug(f"üîç Result {i}: {name}, {country}")
                
            except Exception as e:
                self._logger.warning(f"‚ö†Ô∏è Eredm√©ny {i} feldolgoz√°si hiba: {e}")
                continue
        
        # Rendez√©s relevancia szerint
        processed.sort(key=lambda x: x['search_rank'])
        self._logger.info(f"üîç Results sorted by relevance")
        
        return processed
    
    def _create_display_name(self, result: Dict[str, Any]) -> str:
        """
        Felhaszn√°l√≥bar√°t megjelen√≠t√©si n√©v l√©trehoz√°sa.
        
        Args:
            result: Geocoding eredm√©ny
            
        Returns:
            Form√°zott megjelen√≠t√©si n√©v
        """
        name = result.get('name', 'Ismeretlen')
        admin1 = result.get('admin1', '')
        country = result.get('country', '')
        
        display_parts = [name]
        
        if admin1:
            display_parts.append(admin1)
        
        if country:
            display_parts.append(country)
        
        return ', '.join(display_parts)
    
    # === TELEP√úL√âS KIV√ÅLASZT√ÅS LOGIKA (MEG≈êRIZVE) ===
    
    @Slot(str, float, float, dict)
    def handle_city_selection(self, city_name: str, latitude: float, longitude: float, metadata: Dict[str, Any]) -> None:
        """
        Telep√ºl√©s kiv√°laszt√°s kezel√©se a ControlPanel-t≈ël.
        
        Args:
            city_name: Telep√ºl√©s neve
            latitude: F√∂ldrajzi sz√©less√©g
            longitude: F√∂ldrajzi hossz√∫s√°g  
            metadata: Tov√°bbi metaadatok
        """
        self._logger.info(f"üîç handle_city_selection called: {city_name} ({latitude:.4f}, {longitude:.4f})")
        
        try:
            # Kiv√°lasztott telep√ºl√©s adatainak ment√©se
            self.current_city_data = {
                'name': city_name,
                'latitude': latitude,
                'longitude': longitude,
                'metadata': metadata,
                'selected_at': datetime.now().isoformat(),
            }
            
            # St√°tusz friss√≠t√©se
            status_msg = f"Kiv√°lasztva: {city_name}"
            self.status_updated.emit(status_msg)
            self._logger.info(f"üîç City selection status: {status_msg}")
            
            # Adatb√°zisba ment√©s (aszinkron)
            self._save_city_to_database(self.current_city_data)
            
            self._logger.info(f"‚úÖ Telep√ºl√©s kiv√°lasztva: {city_name} ({latitude:.4f}, {longitude:.4f})")
            
        except Exception as e:
            self._logger.error(f"Telep√ºl√©s kiv√°laszt√°si hiba: {e}")
            self.error_occurred.emit(f"Telep√ºl√©s kiv√°laszt√°si hiba: {e}")
    
    def _save_city_to_database(self, city_data: Dict[str, Any]) -> None:
        """
        Telep√ºl√©s adatok ment√©se adatb√°zisba.
        
        Args:
            city_data: Telep√ºl√©s adatok
        """
        try:
            conn = sqlite3.connect(str(self.db_path))
            cursor = conn.cursor()
            
            # Upsert (INSERT OR REPLACE) m≈±velet
            cursor.execute('''
                INSERT OR REPLACE INTO cities (name, latitude, longitude, country, region)
                VALUES (?, ?, ?, ?, ?)
            ''', (
                city_data['name'],
                city_data['latitude'], 
                city_data['longitude'],
                city_data['metadata'].get('country', ''),
                city_data['metadata'].get('admin1', '')
            ))
            
            conn.commit()
            conn.close()
            
            # Sikeres ment√©s jelz√©se
            self.city_saved_to_db.emit(city_data)
            
            self._logger.info(f"‚úÖ Telep√ºl√©s mentve adatb√°zisba: {city_data['name']}")
            
        except Exception as e:
            self._logger.error(f"Adatb√°zis ment√©si hiba: {e}")
            # Nem kritikus hiba, nem szak√≠tjuk meg a folyamatot
    
    # === ID≈êJ√ÅR√ÅSI ADATOK LEK√âRDEZ√âS LOGIKA (MEG≈êRIZVE, DE DEPRECATED) ===
    
    @Slot(float, float, str, str, dict)
    def handle_weather_data_request(self, latitude: float, longitude: float, 
                                   start_date: str, end_date: str, params: Dict[str, Any]) -> None:
        """
        üåêüå™Ô∏è DEPRECATED: Id≈ëj√°r√°si adatok lek√©rdez√©s (haszn√°ld handle_analysis_request-et helyette)
        
        Args:
            latitude: F√∂ldrajzi sz√©less√©g
            longitude: F√∂ldrajzi hossz√∫s√°g
            start_date: Kezd≈ë d√°tum (YYYY-MM-DD)
            end_date: Befejez≈ë d√°tum (YYYY-MM-DD)
            params: API param√©terek
        """
        self._logger.warning("üåêüå™Ô∏è DEPRECATED: handle_weather_data_request haszn√°lata. Haszn√°ld handle_analysis_request-et!")
        
        # Konvert√°l√°s √∫j form√°tumra √©s tov√°bb√≠t√°s
        analysis_request = {
            'analysis_type': 'single_location',
            'location_data': {
                'lat': latitude,
                'lon': longitude,
                'name': self.current_city_data.get('name', 'Unknown') if self.current_city_data else 'Unknown'
            },
            'date_range': {
                'start_date': start_date,
                'end_date': end_date
            },
            'api_params': params
        }
        
        self.handle_analysis_request(analysis_request)
    
    @Slot(dict)
    def _on_weather_data_completed(self, data: Dict[str, Any]) -> None:
        """
        üåêüå™Ô∏è Id≈ëj√°r√°si adatok lek√©rdez√©s√©nek befejez√©se (backwards compatibility).
        
        Args:
            data: API v√°lasz adatok
        """
        self._logger.info(f"üåêüå™Ô∏è _on_weather_data_completed called (backwards compatibility)")
        
        try:
            # Provider inform√°ci√≥ kinyer√©se az adatokb√≥l
            used_provider = data.get('provider', 'unknown')
            self._logger.info(f"üåê Weather data received from provider: {used_provider}")
            
            # Adatok feldolgoz√°sa √©s valid√°l√°sa
            processed_data = self._process_weather_data(data)
            
            if not processed_data:
                self.error_occurred.emit("Nincs feldolgozhat√≥ id≈ëj√°r√°si adat")
                return
            
            # Provider inform√°ci√≥ hozz√°ad√°sa a feldolgozott adatokhoz
            processed_data['provider'] = used_provider
            
            # Jelenlegi adatok ment√©se
            self.current_weather_data = processed_data
            
            # Adatb√°zisba ment√©s (aszinkron)
            self._save_weather_to_database(processed_data)
            
            # St√°tusz friss√≠t√©se
            city_name = self.current_city_data.get('name', 'Ismeretlen') if self.current_city_data else 'Ismeretlen'
            record_count = len(processed_data.get('daily', {}).get('time', []))
            
            # üå™Ô∏è Sz√©ll√∂k√©s statisztika a st√°tuszban
            wind_gusts_info = ""
            if 'wind_gusts_max' in processed_data.get('daily', {}):
                wind_gusts_max = processed_data['daily']['wind_gusts_max']
                if wind_gusts_max:
                    max_gust = max([g for g in wind_gusts_max if g is not None])
                    wind_gusts_info = f", max sz√©ll√∂k√©s: {max_gust:.1f} km/h"
            
            # üåê Provider info a st√°tuszban
            provider_display = self.provider_config.PROVIDERS.get(used_provider, {}).get('name', used_provider)
            
            self.status_updated.emit(
                f"üåêüå™Ô∏è Adatok sikeresen lek√©rdezve ({provider_display}): {city_name} ({record_count} nap{wind_gusts_info})"
            )
            
            # Eredm√©nyek tov√°bb√≠t√°sa a GUI komponenseknek
            self._logger.info(f"üì° Emitting weather_data_ready signal...")
            self.weather_data_ready.emit(processed_data)
            
            self._logger.info(f"‚úÖ Weather data befejezve: {record_count} napi rekord (backwards compatibility)")
            
        except Exception as e:
            self._logger.error(f"Weather data feldolgoz√°si hiba: {e}")
            import traceback
            traceback.print_exc()
            self.error_occurred.emit(f"Adatok feldolgoz√°si hiba: {e}")
    
    def _process_weather_data(self, raw_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        üå™Ô∏è KRITIKUS SZ√âLSEBESS√âG JAV√çT√ÅS: Id≈ëj√°r√°si adatok feldolgoz√°sa WIND SPEED + WIND GUSTS teljes t√°mogat√°ssal.
        üåπ SZ√âLIR√ÅNY KOMPATIBILIT√ÅSI FIX: winddirection_10m_dominant ‚Üí wind_direction_10m_dominant mapping
        
        Args:
            raw_data: Nyers API adatok
            
        Returns:
            Feldolgozott adatok vagy None
        """
        try:
            self._logger.info(f"üå™Ô∏èüåπ Processing weather data (COMPLETE WIND DATA + WIND DIRECTION FIX)...")
            
            if not raw_data or 'daily' not in raw_data:
                self._logger.warning(f"‚ö†Ô∏è Invalid weather data structure")
                return None
            
            daily_data = raw_data['daily']
            hourly_data = raw_data.get('hourly', {})
            
            # Alapvet≈ë mez≈ëk ellen≈ërz√©se
            required_fields = ['time', 'temperature_2m_max', 'temperature_2m_min', 'precipitation_sum']
            for field in required_fields:
                if field not in daily_data or not daily_data[field]:
                    self._logger.warning(f"‚ö†Ô∏è Hi√°nyz√≥ mez≈ë: {field}")
                    return None
            
            record_count = len(daily_data['time'])
            self._logger.info(f"üå™Ô∏èüåπ Weather data valid - {record_count} records")
            
            # üåπ DEBUG: Eredeti adatok kulcsainak ellen≈ërz√©se
            self._logger.info(f"üåπ DEBUG: daily_data keys: {list(daily_data.keys())}")
            
            # üåπ KRITIKUS JAV√çT√ÅS: Sz√©lir√°ny adatok ellen≈ërz√©se √©s debug
            if 'winddirection_10m_dominant' in daily_data:
                wind_direction_data = daily_data['winddirection_10m_dominant']
                valid_directions = [d for d in wind_direction_data if d is not None]
                self._logger.info(f"üåπ DEBUG: winddirection: {len(valid_directions)} elems")
                if valid_directions:
                    self._logger.info(f"üåπ Found wind direction data: {len(valid_directions)} valid values")
                    self._logger.info(f"üåπ Wind direction range: {min(valid_directions):.0f}¬∞ ‚Üí {max(valid_directions):.0f}¬∞")
                else:
                    self._logger.warning(f"üåπ No valid wind direction data found!")
            else:
                self._logger.warning(f"üåπ No winddirection_10m_dominant field found in daily_data!")
            
            # üå™Ô∏è KRITIKUS JAV√çT√ÅS: √ìr√°nk√©nti sz√©ll√∂k√©sek ‚Üí napi maximum sz√°m√≠t√°s
            daily_wind_gusts_max = self._calculate_daily_max_wind_gusts(
                hourly_data.get('wind_gusts_10m', []),
                hourly_data.get('time', []),
                daily_data.get('time', [])
            )
            
            # üå™Ô∏è KRITIKUS JAV√çT√ÅS: Feldolgozott adatok struktur√°lt √∂ssze√°ll√≠t√°sa
            processed = {
                'daily': {},  # üöÄ KEZDETBEN √úRES - Explicit felt√∂lt√©s k√∂vetkezik!
                'hourly': hourly_data,  # √ìr√°nk√©nti adatok megtart√°sa
                'latitude': raw_data.get('latitude'),
                'longitude': raw_data.get('longitude'),
                'timezone': raw_data.get('timezone', 'UTC'),
                'elevation': raw_data.get('elevation'),
                
                # Metaadatok
                'data_source': raw_data.get('provider', 'unknown'),
                'source_type': raw_data.get('provider', 'unknown'),
                'provider': raw_data.get('provider', 'unknown'),  # üåê Provider info biztos√≠t√°sa
                'processed_at': datetime.now().isoformat(),
                'city_data': self.current_city_data.copy() if self.current_city_data else None,
                'record_count': record_count
            }
            
            # üöÄ KRITIKUS JAV√çT√ÅS: Napi adatok explicit m√°sol√°sa, bele√©rtve a sz√©lsebess√©get is!
            required_daily_fields = [
                'time', 'temperature_2m_max', 'temperature_2m_min', 'precipitation_sum',
                'windspeed_10m_max'  # üå™Ô∏è EZ A HI√ÅNYZ√ì L√ÅNCSZEM!
            ]
            
            self._logger.info(f"üå™Ô∏è Explicit copying of daily fields...")
            for field in required_daily_fields:
                if field in daily_data:
                    processed['daily'][field] = daily_data[field]
                    self._logger.debug(f"üå™Ô∏è Copied field: {field} ({len(daily_data[field])} values)")
                else:
                    self._logger.warning(f"‚ö†Ô∏è Missing field in daily_data: {field}")
            
            # Tov√°bbi opcion√°lis mez≈ëk m√°sol√°sa
            optional_daily_fields = [
                'windspeed_10m_mean', 'winddirection_10m_dominant', 
                'apparent_temperature_max', 'apparent_temperature_min',
                'shortwave_radiation_sum', 'et0_fao_evapotranspiration'
            ]
            
            for field in optional_daily_fields:
                if field in daily_data:
                    processed['daily'][field] = daily_data[field]
                    self._logger.debug(f"üå™Ô∏è Copied optional field: {field}")
            
            # üå™Ô∏è KRITIKUS JAV√çT√ÅS: Napi maximum sz√©ll√∂k√©sek hozz√°ad√°sa
            if daily_wind_gusts_max:
                processed['daily']['wind_gusts_max'] = daily_wind_gusts_max
                self._logger.info(f"üå™Ô∏è Added {len(daily_wind_gusts_max)} daily wind gusts max values")
                
                # Statisztika
                valid_gusts = [g for g in daily_wind_gusts_max if g is not None and g > 0]
                if valid_gusts:
                    max_gust = max(valid_gusts)
                    self._logger.info(f"üå™Ô∏è Maximum napi sz√©ll√∂k√©s: {max_gust:.1f} km/h")
                    
                    # Kritikus ellen≈ërz√©s - √©letvesz√©lyes alulbecsl√©s detekt√°l√°sa
                    if max_gust > 100:
                        self._logger.warning(f"‚ö†Ô∏è  KRITIKUS: Extr√©m sz√©ll√∂k√©s detekt√°lva: {max_gust:.1f} km/h")
                    elif max_gust > 80:
                        self._logger.warning(f"‚ö†Ô∏è  Viharos sz√©ll√∂k√©s detekt√°lva: {max_gust:.1f} km/h")
                    elif max_gust > 60:
                        self._logger.info(f"‚úÖ Er≈ës sz√©ll√∂k√©s detekt√°lva: {max_gust:.1f} km/h")
                    else:
                        self._logger.info(f"‚úÖ M√©rs√©kelt sz√©ll√∂k√©s: {max_gust:.1f} km/h")
            else:
                self._logger.warning(f"‚ö†Ô∏è Nincs sz√©ll√∂k√©s adat az √≥r√°nk√©nti adatokban")
            
            # üå™Ô∏è KRITIKUS ELLEN≈êRZ√âS: Sz√©lsebess√©g adat jelenl√©t valid√°l√°sa
            if 'windspeed_10m_max' in processed['daily']:
                wind_speeds = processed['daily']['windspeed_10m_max']
                valid_speeds = [s for s in wind_speeds if s is not None and s > 0]
                if valid_speeds:
                    max_speed = max(valid_speeds)
                    avg_speed = sum(valid_speeds) / len(valid_speeds)
                    self._logger.info(f"üå™Ô∏è Sz√©lsebess√©g adatok sikeresen feldolgozva:")
                    self._logger.info(f"üå™Ô∏è - Maximum sz√©lsebess√©g: {max_speed:.1f} km/h")
                    self._logger.info(f"üå™Ô∏è - √Åtlagos sz√©lsebess√©g: {avg_speed:.1f} km/h")
                    self._logger.info(f"üå™Ô∏è - √ârv√©nyes napok: {len(valid_speeds)}/{len(wind_speeds)}")
                else:
                    self._logger.warning(f"‚ö†Ô∏è Sz√©lsebess√©g adatok √ºresek vagy null√°k!")
            else:
                self._logger.error(f"‚ùå KRITIKUS: windspeed_10m_max NEM ker√ºlt √°t a feldolgozott adatokba!")
                self._logger.error(f"‚ùå Available daily fields: {list(processed['daily'].keys())}")
                self._logger.error(f"‚ùå Original daily fields: {list(daily_data.keys())}")
            
            self._logger.info(f"‚úÖ Weather data processed successfully with COMPLETE WIND DATA - {record_count} records")
            self._logger.info(f"üå™Ô∏è Final processed daily fields: {list(processed['daily'].keys())}")

            # === üåπ KRITIKUS SZ√âLIR√ÅNY KOMPATIBILIT√ÅSI FIX ===
            # Biztos√≠tja, hogy a WindRoseChart megkapja az adatot a v√°rt kulccsal.
            if 'winddirection_10m_dominant' in daily_data:
                processed['daily']['wind_direction_10m_dominant'] = daily_data['winddirection_10m_dominant']
                self._logger.info("‚úÖ Wind direction data mapped for WindRoseChart compatibility.")
            
            return processed
            
        except Exception as e:
            self._logger.error(f"Weather data feldolgoz√°si hiba: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    def _calculate_daily_max_wind_gusts(self, hourly_gusts: List[float], 
                                       hourly_times: List[str], 
                                       daily_times: List[str]) -> List[float]:
        """
        üå™Ô∏è KRITIKUS JAV√çT√ÅS: √ìr√°nk√©nti sz√©ll√∂k√©sek ‚Üí napi maximum konverzi√≥ja.
        
        Args:
            hourly_gusts: √ìr√°nk√©nti sz√©ll√∂k√©sek (km/h)
            hourly_times: √ìr√°nk√©nti id≈ëpontok (ISO format)
            daily_times: Napi id≈ëpontok (YYYY-MM-DD format)
            
        Returns:
            Napi maximum sz√©ll√∂k√©sek list√°ja
        """
        try:
            self._logger.info(f"üå™Ô∏è Calculating daily max wind gusts...")
            self._logger.info(f"üå™Ô∏è Hourly gusts count: {len(hourly_gusts)}")
            self._logger.info(f"üå™Ô∏è Hourly times count: {len(hourly_times)}")
            self._logger.info(f"üå™Ô∏è Daily times count: {len(daily_times)}")
            
            if not hourly_gusts or not hourly_times or not daily_times:
                self._logger.warning(f"‚ö†Ô∏è Missing data for wind gusts calculation")
                return []
            
            # √ìr√°nk√©nti adatok DataFrame-be konvert√°l√°sa
            hourly_df = pd.DataFrame({
                'time': pd.to_datetime(hourly_times),
                'wind_gusts': hourly_gusts
            })
            
            # Datum oszlop hozz√°ad√°sa (√≥r√°nk√©nti id≈ëpontokb√≥l)
            hourly_df['date'] = hourly_df['time'].dt.date
            
            # Napi maximumok sz√°m√≠t√°sa
            daily_max_gusts = []
            
            for daily_time in daily_times:
                try:
                    # Napi d√°tum konvert√°l√°sa
                    daily_date = pd.to_datetime(daily_time).date()
                    
                    # Adott nap √≥r√°nk√©nti sz√©ll√∂k√©sei
                    day_gusts = hourly_df[hourly_df['date'] == daily_date]['wind_gusts']
                    
                    if not day_gusts.empty:
                        # Csak √©rv√©nyes √©rt√©kek (nem None, nem NaN)
                        valid_gusts = day_gusts.dropna()
                        
                        if not valid_gusts.empty:
                            daily_max = valid_gusts.max()
                            daily_max_gusts.append(daily_max)
                            
                            # Debug logol√°s minden 10. naphoz
                            if len(daily_max_gusts) % 10 == 0:
                                self._logger.debug(f"üå™Ô∏è Day {daily_time}: max gust {daily_max:.1f} km/h")
                        else:
                            # Nincs √©rv√©nyes sz√©ll√∂k√©s adat erre a napra
                            daily_max_gusts.append(None)
                    else:
                        # Nincs √≥r√°nk√©nti adat erre a napra
                        daily_max_gusts.append(None)
                        
                except Exception as e:
                    self._logger.warning(f"‚ö†Ô∏è Error processing day {daily_time}: {e}")
                    daily_max_gusts.append(None)
            
            # Eredm√©ny valid√°l√°s
            valid_gusts = [g for g in daily_max_gusts if g is not None and g > 0]
            
            if valid_gusts:
                max_overall = max(valid_gusts)
                avg_gusts = sum(valid_gusts) / len(valid_gusts)
                
                self._logger.info(f"üå™Ô∏è Daily wind gusts calculation complete:")
                self._logger.info(f"üå™Ô∏è - Valid days: {len(valid_gusts)}/{len(daily_max_gusts)}")
                self._logger.info(f"üå™Ô∏è - Maximum overall: {max_overall:.1f} km/h")
                self._logger.info(f"üå™Ô∏è - Average gusts: {avg_gusts:.1f} km/h")
                
                # Kritikus ellen≈ërz√©s - √©letvesz√©lyes alulbecsl√©s detekt√°l√°sa
                if max_overall > 120:
                    self._logger.critical(f"üö® KRITIKUS: Hurrik√°n er≈ëss√©g≈± sz√©ll√∂k√©s: {max_overall:.1f} km/h")
                elif max_overall > 100:
                    self._logger.warning(f"‚ö†Ô∏è  KRITIKUS: Extr√©m sz√©ll√∂k√©s: {max_overall:.1f} km/h")
                elif max_overall > 80:
                    self._logger.warning(f"‚ö†Ô∏è  Viharos sz√©ll√∂k√©s: {max_overall:.1f} km/h")
                else:
                    self._logger.info(f"‚úÖ M√©rs√©kelt sz√©ll√∂k√©s: {max_overall:.1f} km/h")
                    
            else:
                self._logger.warning(f"‚ö†Ô∏è Nincs √©rv√©nyes sz√©ll√∂k√©s adat")
            
            return daily_max_gusts
            
        except Exception as e:
            self._logger.error(f"Daily wind gusts calculation error: {e}")
            import traceback
            traceback.print_exc()
            return []
    
    def _save_weather_to_database(self, weather_data: Dict[str, Any]) -> None:
        """
        üåêüå™Ô∏è KRITIKUS JAV√çT√ÅS: Id≈ëj√°r√°si adatok ment√©se adatb√°zisba PROVIDER ROUTING + WIND GUSTS t√°mogat√°ssal.
        
        Args:
            weather_data: Feldolgozott id≈ëj√°r√°si adatok
        """
        try:
            if not self.current_city_data:
                self._logger.warning("‚ö†Ô∏è Nincs v√°ros adat az id≈ëj√°r√°si adatok ment√©s√©hez")
                return
            
            conn = sqlite3.connect(str(self.db_path))
            cursor = conn.cursor()
            
            # V√°ros ID lek√©rdez√©se
            cursor.execute('SELECT id FROM cities WHERE name = ? AND latitude = ? AND longitude = ?', 
                          (self.current_city_data['name'], 
                           self.current_city_data['latitude'],
                           self.current_city_data['longitude']))
            
            city_result = cursor.fetchone()
            if not city_result:
                self._logger.warning("‚ö†Ô∏è V√°ros nem tal√°lhat√≥ az adatb√°zisban")
                conn.close()
                return
            
            city_id = city_result[0]
            daily_data = weather_data['daily']
            
            # üåê Provider inform√°ci√≥
            data_provider = weather_data.get('provider', 'unknown')
            
            # Id≈ëj√°r√°si adatok ment√©se
            saved_count = 0
            for i, date in enumerate(daily_data['time']):
                try:
                    # üå™Ô∏è KRITIKUS JAV√çT√ÅS: wind_gusts_max oszlop hozz√°ad√°sa
                    wind_gusts_max = None
                    if 'wind_gusts_max' in daily_data and i < len(daily_data['wind_gusts_max']):
                        wind_gusts_max = daily_data['wind_gusts_max'][i]
                    
                    # üå™Ô∏è KRITIKUS JAV√çT√ÅS: windspeed_10m_max proper handling
                    windspeed_max = None
                    if 'windspeed_10m_max' in daily_data and i < len(daily_data['windspeed_10m_max']):
                        windspeed_max = daily_data['windspeed_10m_max'][i]
                    
                    cursor.execute('''
                        INSERT OR REPLACE INTO weather_data 
                        (city_id, date, temp_max, temp_min, precipitation, windspeed_max, wind_gusts_max, data_provider)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        city_id,
                        date,
                        daily_data['temperature_2m_max'][i] if i < len(daily_data['temperature_2m_max']) else None,
                        daily_data['temperature_2m_min'][i] if i < len(daily_data['temperature_2m_min']) else None,
                        daily_data['precipitation_sum'][i] if i < len(daily_data['precipitation_sum']) else None,
                        windspeed_max,      # üå™Ô∏è KRITIKUS JAV√çT√ÅS: Proper windspeed_max haszn√°lata
                        wind_gusts_max,     # üå™Ô∏è KRITIKUS JAV√çT√ÅS: √öj wind_gusts_max oszlop
                        data_provider       # üåê Provider tracking
                    ))
                    saved_count += 1
                    
                    # Debug logol√°s sz√©lsebess√©g + sz√©ll√∂k√©sekhez
                    if windspeed_max is not None and windspeed_max > 40:
                        self._logger.info(f"üå™Ô∏è Saved high wind speed ({data_provider}): {date} - {windspeed_max:.1f} km/h")
                    if wind_gusts_max is not None and wind_gusts_max > 80:
                        self._logger.info(f"üå™Ô∏è Saved extreme wind gust ({data_provider}): {date} - {wind_gusts_max:.1f} km/h")
                        
                except Exception as e:
                    self._logger.warning(f"‚ö†Ô∏è Rekord ment√©si hiba: {e}")
                    continue
            
            conn.commit()
            conn.close()
            
            # Sikeres ment√©s jelz√©se
            self.weather_saved_to_db.emit(True)
            
            self._logger.info(f"‚úÖ Weather data mentve adatb√°zisba ({data_provider}): {saved_count} rekord")
            
        except Exception as e:
            self._logger.error(f"Weather data adatb√°zis hiba: {e}")
            self.weather_saved_to_db.emit(False)
    
    # === HIBA KEZEL√âS ===
    
    @Slot(str)
    def _on_worker_error(self, error_message: str) -> None:
        """
        Worker hib√°k kezel√©se.
        
        Args:
            error_message: Hiba√ºzenet
        """
        self._logger.error(f"Worker error: {error_message}")
        
        self.status_updated.emit(f"Hiba: {error_message}")
        self.error_occurred.emit(error_message)
    
    # === PUBLIKUS API ===
    
    def get_current_city(self) -> Optional[Dict[str, Any]]:
        """Jelenlegi kiv√°lasztott v√°ros adatainak lek√©rdez√©se."""
        return self.current_city_data.copy() if self.current_city_data else None
    
    def get_current_weather_data(self) -> Optional[Dict[str, Any]]:
        """Jelenlegi id≈ëj√°r√°si adatok lek√©rdez√©se."""
        return self.current_weather_data.copy() if self.current_weather_data else None
    
    def get_provider_info(self) -> Dict[str, Any]:
        """
        üåê Provider inform√°ci√≥k lek√©rdez√©se GUI sz√°m√°ra.
        
        Returns:
            Provider inform√°ci√≥k √©s statistics
        """
        try:
            current_provider = self.user_preferences.get_selected_provider()
            usage_summary = self.usage_tracker.get_usage_summary()
            
            return {
                'current_provider': current_provider,
                'usage_summary': usage_summary,
                'available_providers': list(self.provider_config.PROVIDERS.keys()),
                'provider_configs': self.provider_config.PROVIDERS
            }
        except Exception as e:
            self._logger.error(f"Provider info hiba: {e}")
            return {}
    
    def cancel_all_operations(self) -> None:
        """
        üõë √ñsszes akt√≠v m≈±velet megszak√≠t√°sa.
        """
        try:
            self._logger.info("üõë Cancelling all operations...")
            
            # Analysis Worker megszak√≠t√°sa
            if self.is_analysis_running():
                self.stop_current_analysis()
            
            # WorkerManager k√∂zponti cancel
            self.worker_manager.cancel_all()
            
            self.status_updated.emit("üõë M≈±veletek megszak√≠tva")
            self._logger.info("‚úÖ √ñsszes m≈±velet megszak√≠tva")
            
        except Exception as e:
            self._logger.error(f"M≈±veletek megszak√≠t√°si hiba: {e}")
    
    def shutdown(self) -> None:
        """Controller le√°ll√≠t√°sa √©s cleanup."""
        try:
            self._logger.info("üõë AppController le√°ll√≠t√°sa...")
            
            # √ñsszes m≈±velet megszak√≠t√°sa
            self.cancel_all_operations()
            
            # Analysis worker cleanup
            self._cleanup_analysis_state()
            
            # WorkerManager k√∂zponti le√°ll√≠t√°s
            self.worker_manager.shutdown()
            
            # User preferences ment√©se
            self.user_preferences.save()
            self.usage_tracker.save()
            
            # √Ållapot tiszt√≠t√°sa
            self.current_city_data = None
            self.current_weather_data = None
            self.active_search_query = None
            
            self._logger.info("‚úÖ AppController le√°ll√≠tva (CLEAN ARCHITECTURE)")
            
        except Exception as e:
            self._logger.warning(f"‚ö†Ô∏è Controller le√°ll√≠t√°si hiba: {e}")
            import traceback
            traceback.print_exc()