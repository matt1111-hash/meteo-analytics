#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Universal Weather Research Platform - Control Panel (CLEAN ARCHITECTURE)
SIGNAL AGGREGATOR PATTERN - MULTI-CITY WIDGET INTEGR√ÅCI√ì BEFEJEZVE!

üéØ CLEAN ARCHITECTURE + MULTI-CITY T√ÅMOGAT√ÅS:
- Single Responsibility: Widget aggreg√°ci√≥ √©s egyetlen signal routing
- Signal Aggregation: CSAK analysis_requested = Signal(dict) - F≈êCSATORNA  
- Widget Composition: 7 specializ√°lt widget komponens (+ MultiCityWidget)
- State Management: get_current_state() minden widget-b≈ël
- üèôÔ∏è MULTI-CITY WIDGET INTEGR√ÅCI√ì: R√©gi√≥/megye v√°laszt√°s t√°mogat√°s
- üîÑ ANALYSIS TYPE V√ÅLT√ÅS: LocationWidget ‚Üî MultiCityWidget dinamikus v√°lt√°s
- üì° SIGNAL ROUTING: Multi-city selection_changed signal kezel√©s

üîß KRITIKUS JAV√çT√ÅSOK BEFEJEZVE:
‚úÖ _update_ui_for_analysis_type_fixed() - Widget v√°lt√°s LocationWidget ‚Üî MultiCityWidget
‚úÖ _preserve_widget_states() - State meg≈ërz√©s analysis type v√°lt√°s el≈ëtt  
‚úÖ _restore_widget_states() - State vissza√°ll√≠t√°s analysis type v√°lt√°s ut√°n
‚úÖ _force_widget_refresh() - Widget bels≈ë √°llapot refresh
‚úÖ _comprehensive_fetch_validation() - Robusztus fetch button logic
‚úÖ Debug logging minden kritikus pontra
‚úÖ üèôÔ∏è MultiCityWidget integr√°ci√≥ analysis_type alap√∫ mode v√°lt√°ssal
‚úÖ üì° Multi-city selection signal routing
‚úÖ üö® DATE RANGE FIX: AppController kompatibilis form√°tum
‚úÖ üö® VALIDATION FIX: location_data objektum alatt keresi lat/lon kulcsokat

üìã WIDGET HIERARCHIA (KIEG√âSZ√çTVE):
- AnalysisTypeWidget: Egyedi/R√©gi√≥/Megye v√°laszt√≥
- LocationWidget: UniversalLocationSelector wrapper (single_location m√≥dban) ‚úÖ 
- MultiCityWidget: Magyar r√©gi√≥k/megy√©k checkbox lista (region/county m√≥dban) ‚úÖ √öJ
- DateRangeWidget: Multi-year + Manual d√°tum v√°laszt√≥
- ProviderWidget: API provider + usage tracking
- ApiSettingsWidget: Timeout, cache, timezone be√°ll√≠t√°sok
- QueryControlWidget: Fetch/cancel gombok + progress
"""

from typing import Optional, List, Dict, Any
from datetime import datetime
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QScrollArea, QFrame, QSizePolicy
)
from PySide6.QtCore import Signal, Qt, QTimer

# Refaktor√°lt widget komponensek
from .panel_widgets.analysis_type_widget import AnalysisTypeWidget
from .panel_widgets.location_widget import LocationWidget  
from .panel_widgets.multi_city_widget import MultiCityWidget  # üèôÔ∏è √öJ: Multi-City Widget
from .panel_widgets.date_range_widget import DateRangeWidget
from .panel_widgets.provider_widget import ProviderWidget
from .panel_widgets.api_settings_widget import ApiSettingsWidget
from .panel_widgets.query_control_widget import QueryControlWidget

from .workers.data_fetch_worker import WorkerManager
from .theme_manager import get_theme_manager
from ..data.city_manager import CityManager


class ControlPanel(QWidget):
    """
    üéØ CLEAN ARCHITECTURE CONTROL PANEL - MULTI-CITY WIDGET INTEGR√ÅCI√ì BEFEJEZVE!
    
    WIDGET HIERARCHIA:
    - AnalysisTypeWidget: Egyedi/R√©gi√≥/Megye v√°laszt√≥
    - LocationWidget: UniversalLocationSelector wrapper (single_location m√≥dban) ‚úÖ 
    - MultiCityWidget: Magyar r√©gi√≥k/megy√©k checkbox lista (region/county m√≥dban) ‚úÖ √öJ
    - DateRangeWidget: Multi-year + Manual d√°tum v√°laszt√≥
    - ProviderWidget: API provider + usage tracking
    - ApiSettingsWidget: Timeout, cache, timezone be√°ll√≠t√°sok
    - QueryControlWidget: Fetch/cancel gombok + progress
    
    CLEAN SIGNAL FLOW:
    üéØ analysis_requested(dict) ‚Üê EGYETLEN KIMEN≈ê SIGNAL
    ‚îú‚îÄ‚îÄ Widget events aggreg√°l√°s
    ‚îú‚îÄ‚îÄ Comprehensive analysis request building
    ‚îî‚îÄ‚îÄ AppController deleg√°l√°s
    
    üèôÔ∏è MULTI-CITY WIDGET INTEGR√ÅCI√ì:
    ‚úÖ Analysis type alap√∫ widget v√°lt√°s (LocationWidget ‚Üî MultiCityWidget)
    ‚úÖ R√©gi√≥/megye selection signal routing
    ‚úÖ State preservation multi-city m√≥dban
    ‚úÖ Comprehensive fetch validation multi-city t√°mogat√°ssal
    ‚úÖ Debug logging minden kritikus pont
    """
    
    # === CLEAN ARCHITECTURE - EGYETLEN KIMEN≈ê SIGNAL ===
    analysis_requested = Signal(dict)  # Comprehensive analysis request
    
    # === MINIM√ÅLIS KOMPATIBILIT√ÅSI SIGNALOK ===
    search_requested = Signal(str)                        # LocationWidget geocoding
    city_selected = Signal(str, float, float, dict)       # LocationWidget selection  
    local_error_occurred = Signal(str)                    # Error handling
    
    def __init__(self, worker_manager: WorkerManager, parent: Optional[QWidget] = None):
        """
        Clean ControlPanel inicializ√°l√°sa.
        
        Args:
            worker_manager: Worker manager (kompatibilit√°s)
            parent: Sz√ºl≈ë widget
        """
        super().__init__(parent)
        
        # Dependencies
        self.worker_manager = worker_manager
        self.city_manager = CityManager()
        self.theme_manager = get_theme_manager()
        
        # üîß WIDGET STATE PRESERVATION
        self._preserved_states: Dict[str, Any] = {}
        self._last_analysis_type = "single_location"
        
        # UI init
        self._init_ui()
        self._connect_widget_signals()
        self._setup_theme()
        
        print("üéØ ControlPanel CLEAN ARCHITECTURE + MULTI-CITY WIDGET - Widget Aggregator Pattern initialized")
    
    def _init_ui(self) -> None:
        """UI strukt√∫ra l√©trehoz√°sa scroll area-val."""
        # Panel size policy
        self.setMinimumWidth(320)
        self.setMaximumWidth(450)
        self.setMinimumHeight(700)
        self.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Expanding)
        
        # Scroll area wrapper
        scroll_area = QScrollArea(self)
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        scroll_area.setFrameShape(QFrame.NoFrame)
        
        # Scroll content widget
        scroll_content = QWidget()
        scroll_area.setWidget(scroll_content)
        
        # Main layout
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.addWidget(scroll_area)
        
        # Content layout
        content_layout = QVBoxLayout(scroll_content)
        content_layout.setContentsMargins(12, 12, 12, 12)
        content_layout.setSpacing(16)
        
        # === WIDGET KOMPONENSEK L√âTREHOZ√ÅSA ===
        
        # 1. Analysis Type Widget
        self.analysis_type_widget = AnalysisTypeWidget()
        content_layout.addWidget(self.analysis_type_widget)
        
        # 2. Location Widget (single_location m√≥dban)
        self.location_widget = LocationWidget(self.city_manager)
        content_layout.addWidget(self.location_widget)
        
        # üèôÔ∏è 3. Multi-City Widget (region/county m√≥dban) - √öJ WIDGET
        self.multi_city_widget = MultiCityWidget(self.city_manager)
        content_layout.addWidget(self.multi_city_widget)
        
        print("üèôÔ∏è DEBUG: MultiCityWidget l√©trehozva √©s hozz√°adva a layout-hoz")
        
        # 4. Date Range Widget
        self.date_range_widget = DateRangeWidget()
        content_layout.addWidget(self.date_range_widget)
        
        # 5. Provider Widget
        self.provider_widget = ProviderWidget()
        content_layout.addWidget(self.provider_widget)
        
        # 6. API Settings Widget
        self.api_settings_widget = ApiSettingsWidget()
        content_layout.addWidget(self.api_settings_widget)
        
        # 7. Query Control Widget
        self.query_control_widget = QueryControlWidget()
        content_layout.addWidget(self.query_control_widget)
        
        # Stretch a v√©g√©n
        content_layout.addStretch()
        
        # üö® KRITIKUS: Kezdeti UI √°llapot be√°ll√≠t√°sa MULTI-CITY T√ÅMOGAT√ÅSSAL
        self._update_ui_for_analysis_type_fixed("single_location")
        
        print("‚úÖ DEBUG: ControlPanel UI setup complete - MULTI-CITY WIDGET INTEGR√ÅLVA")
    
    def _connect_widget_signals(self) -> None:
        """Widget signalok √∂sszek√∂t√©se - CLEAN SIGNAL ROUTING + MULTI-CITY."""
        
        # === 1. ANALYSIS TYPE WIDGET ===
        self.analysis_type_widget.analysis_type_changed.connect(self._on_analysis_type_changed)
        
        # === 2. LOCATION WIDGET ===
        # Kompatibilit√°si signalok (AppController sz√°m√°ra)
        self.location_widget.search_requested.connect(self.search_requested.emit)
        self.location_widget.city_selected.connect(self.city_selected.emit)
        
        # Internal handling
        self.location_widget.location_changed.connect(self._on_location_changed)
        
        # üèôÔ∏è === 3. MULTI-CITY WIDGET (√öJ) ===
        self.multi_city_widget.selection_changed.connect(self._on_multi_city_selection_changed)
        
        # === 4. DATE RANGE WIDGET ===
        self.date_range_widget.date_range_changed.connect(self._on_date_range_changed)
        self.date_range_widget.date_mode_changed.connect(self._on_date_mode_changed)
        
        # === 5. PROVIDER WIDGET ===
        self.provider_widget.provider_changed.connect(self._on_provider_changed)
        
        # === 6. API SETTINGS WIDGET ===
        self.api_settings_widget.api_settings_changed.connect(self._on_api_settings_changed)
        
        # === 7. QUERY CONTROL WIDGET ===
        self.query_control_widget.fetch_requested.connect(self._on_fetch_requested)
        self.query_control_widget.cancel_requested.connect(self._on_cancel_requested)
        
        print("üéØ Clean signal routing connected + MULTI-CITY signals - Single analysis_requested signal")
    
    def _setup_theme(self) -> None:
        """Theme setup - minden widget m√°r regisztr√°lva van saj√°t mag√°ban."""
        if hasattr(self.theme_manager, 'theme_changed'):
            self.theme_manager.theme_changed.connect(self._on_theme_changed)
        
        print("üé® Theme setup completed for clean ControlPanel + MultiCityWidget")
    
    # === WIDGET SIGNAL HANDLERS - CLEAN AGGREGATION + MULTI-CITY ===
    
    def _on_analysis_type_changed(self, analysis_type: str) -> None:
        """
        üîß KRITIKUS FIX: Analysis type v√°ltoz√°s kezel√©se + WIDGET STATE PRESERVATION + MULTI-CITY.
        
        Args:
            analysis_type: √öj analysis type ("single_location", "region", "county")
        """
        print(f"üéØ DEBUG: Analysis type changed from '{self._last_analysis_type}' to '{analysis_type}'")
        
        # 1. WIDGET STATES MEG≈êRZ√âSE (analysis type v√°lt√°s el≈ëtt)
        self._preserve_widget_states()
        
        # 2. UI FRISS√çT√âSE - JAV√çTOTT VERZI√ì MULTI-CITY T√ÅMOGAT√ÅSSAL
        self._update_ui_for_analysis_type_fixed(analysis_type)
        
        # 3. WIDGET STATES VISSZA√ÅLL√çT√ÅSA (analysis type v√°lt√°s ut√°n)
        self._restore_widget_states(analysis_type)
        
        # 4. FETCH BUTTON STATE √öJRA√âRT√âKEL√âSE
        self._update_fetch_button_state_comprehensive()
        
        # 5. LAST ANALYSIS TYPE TRACKING
        self._last_analysis_type = analysis_type
        
        print(f"‚úÖ DEBUG: Analysis type change completed: {analysis_type}")
    
    def _on_location_changed(self, location) -> None:
        """Location v√°ltoz√°s kezel√©se."""
        print(f"üåç Location changed: {location}")
        
        # Fetch button state friss√≠t√©se
        self._update_fetch_button_state_comprehensive()
    
    def _on_multi_city_selection_changed(self, selection_data: Dict[str, Any]) -> None:
        """
        üèôÔ∏è √öJ: Multi-city selection v√°ltoz√°s kezel√©se.
        
        Args:
            selection_data: {"mode": "region", "selected": [...], "count": 3, "is_valid": True}
        """
        mode = selection_data.get("mode", "unknown")
        count = selection_data.get("count", 0)
        selected = selection_data.get("selected", [])
        
        print(f"üèôÔ∏è Multi-city selection changed: {mode} mode, {count} items selected")
        print(f"üìã Selected items: {selected[:3]}{'...' if len(selected) > 3 else ''}")
        
        # Fetch button state friss√≠t√©se
        self._update_fetch_button_state_comprehensive()
    
    def _on_date_range_changed(self, start_date: str, end_date: str) -> None:
        """Date range v√°ltoz√°s kezel√©se."""
        print(f"üìÖ Date range changed: {start_date} ‚Üí {end_date}")
        
        # Fetch button state friss√≠t√©se
        self._update_fetch_button_state_comprehensive()
    
    def _on_date_mode_changed(self, date_mode: str) -> None:
        """Date mode v√°ltoz√°s kezel√©se."""
        print(f"üìÖ Date mode changed: {date_mode}")
        
        # Fetch button state friss√≠t√©se
        self._update_fetch_button_state_comprehensive()
    
    def _on_provider_changed(self, provider: str) -> None:
        """Provider v√°ltoz√°s kezel√©se."""
        print(f"üéõÔ∏è Provider changed: {provider}")
        
        # Fetch button state friss√≠t√©se
        self._update_fetch_button_state_comprehensive()
    
    def _on_api_settings_changed(self, settings: Dict[str, Any]) -> None:
        """API settings v√°ltoz√°s kezel√©se."""
        print(f"‚öôÔ∏è API settings changed: {settings}")
        
        # Fetch button state friss√≠t√©se
        self._update_fetch_button_state_comprehensive()
    
    def _on_fetch_requested(self) -> None:
        """
        üéØ FETCH REQUEST KEZEL√âSE - F≈êSIGNAL KIBOCS√ÅT√ÅS + MULTI-CITY T√ÅMOGAT√ÅS
        
        Ez a CLEAN ARCHITECTURE k√∂zponti pontja:
        1. Widget state aggreg√°l√°s (+ multi-city)
        2. Analysis request building
        3. Valid√°l√°s
        4. analysis_requested(dict) signal emit
        """
        print("üöÄ Fetch requested - generating clean analysis request + multi-city support")
        
        # Comprehensive analysis request √∂ssze√°ll√≠t√°sa
        analysis_request = self._build_analysis_request()
        
        if self._validate_analysis_request(analysis_request):
            # Fetch state be√°ll√≠t√°sa
            self.query_control_widget.set_fetching_state(True)
            
            # üéØ F≈êSIGNAL KIBOCS√ÅT√ÅSA - CLEAN ARCHITECTURE
            self.analysis_requested.emit(analysis_request)
            
            print(f"üéØ CLEAN: analysis_requested emitted ‚Üí {analysis_request['analysis_type']}")
            
            # üîß AUTO-RESET FETCH STATE - Error eset√©re timeout
            from PySide6.QtCore import QTimer
            QTimer.singleShot(2000, self._auto_reset_fetch_state)  # 2 sec ut√°n reset
            
        else:
            print("‚ùå ERROR: Invalid analysis request")
            # üîß FETCH STATE RESET on validation failure
            self.query_control_widget.set_fetching_state(False)
            self.local_error_occurred.emit("Hi√°nyos vagy √©rv√©nytelen be√°ll√≠t√°sok")
    
    def _on_cancel_requested(self) -> None:
        """Cancel request kezel√©se."""
        print("‚õî Cancel requested")
        
        # Worker manager stop
        if self.worker_manager:
            self.worker_manager.stop_all_workers()
        
        # UI reset
        self.query_control_widget.set_fetching_state(False)
        self._update_fetch_button_state_comprehensive()
    
    def _on_theme_changed(self, theme_name: str) -> None:
        """Theme v√°ltoz√°s kezel√©se."""
        print(f"üé® Theme changed to: {theme_name}")
        # Widget-ek saj√°t maguk kezelik a theme v√°ltoz√°st
    
    # === üîß KRITIKUS FIX: UI MANAGEMENT LOGIC - MULTI-CITY WIDGET V√ÅLT√ÅS ===
    
    def _preserve_widget_states(self) -> None:
        """
        üîß Widget √°llapotok meg≈ërz√©se analysis type v√°lt√°s el≈ëtt + MULTI-CITY.
        """
        print("üíæ DEBUG: Preserving widget states before analysis type change...")
        
        try:
            self._preserved_states = {
                "location": self.location_widget.get_state(),
                "multi_city": self.multi_city_widget.get_state(),  # üèôÔ∏è √öJ
                "date_range": self.date_range_widget.get_state(),
                "provider": self.provider_widget.get_state(),
                "api_settings": self.api_settings_widget.get_state()
            }
            
            location_valid = self._preserved_states['location'].get('is_valid', False)
            multi_city_valid = self._preserved_states['multi_city'].get('is_valid', False)
            print(f"‚úÖ DEBUG: Widget states preserved - location: {location_valid}, multi-city: {multi_city_valid}")
            
        except Exception as e:
            print(f"‚ö†Ô∏è DEBUG: Error preserving widget states: {e}")
            self._preserved_states = {}
    
    def _restore_widget_states(self, analysis_type: str) -> None:
        """
        üîß Widget √°llapotok vissza√°ll√≠t√°sa analysis type v√°lt√°s ut√°n + MULTI-CITY.
        
        Args:
            analysis_type: Aktu√°lis analysis type
        """
        print(f"üîÑ DEBUG: Restoring widget states for analysis type: {analysis_type}")
        
        try:
            # Location widget state vissza√°ll√≠t√°sa (csak single_location m√≥dban)
            if analysis_type == "single_location" and "location" in self._preserved_states:
                location_state = self._preserved_states["location"]
                if location_state.get("has_location", False):
                    print("üîÑ DEBUG: Restoring location widget state...")
                    self.location_widget.set_state(location_state)
            
            # üèôÔ∏è Multi-city widget state vissza√°ll√≠t√°sa (csak region/county m√≥dban)
            if analysis_type in ["region", "county"] and "multi_city" in self._preserved_states:
                multi_city_state = self._preserved_states["multi_city"]
                if multi_city_state.get("is_valid", False):
                    print(f"üèôÔ∏è DEBUG: Restoring multi-city widget state for {analysis_type}...")
                    self.multi_city_widget.set_state(multi_city_state)
            
            # Egy√©b widget states vissza√°ll√≠t√°sa
            if "date_range" in self._preserved_states:
                self.date_range_widget.set_state(self._preserved_states["date_range"])
            
            if "provider" in self._preserved_states:
                self.provider_widget.set_state(self._preserved_states["provider"])
            
            if "api_settings" in self._preserved_states:
                self.api_settings_widget.set_state(self._preserved_states["api_settings"])
            
            print("‚úÖ DEBUG: Widget states restored successfully")
            
        except Exception as e:
            print(f"‚ö†Ô∏è DEBUG: Error restoring widget states: {e}")
    
    def _update_ui_for_analysis_type_fixed(self, analysis_type: str) -> None:
        """
        üîß KRITIKUS FIX: UI elemek megjelen√≠t√©se/elrejt√©se analysis type alapj√°n + MULTI-CITY WIDGET V√ÅLT√ÅS.
        
        Args:
            analysis_type: Analysis type ("single_location", "region", "county")
        """
        print(f"üîß DEBUG: _update_ui_for_analysis_type_fixed called: {analysis_type}")
        
        if analysis_type == "single_location":
            print("üîß DEBUG: Setting UI to single_location mode - LocationWidget MEGJELEN√çT√âSE...")
            
            # === LOCATION WIDGET MEGJELEN√çT√âSE ===
            self.location_widget.setVisible(True)
            self.location_widget.setEnabled(True)
            
            if hasattr(self.location_widget, 'group'):
                self.location_widget.group.setVisible(True)
                self.location_widget.group.setEnabled(True)
            
            # Location widget bels≈ë enable + refresh
            self.location_widget.set_enabled(True)
            self.location_widget.show()
            
            # === MULTI-CITY WIDGET ELREJT√âSE ===
            self.multi_city_widget.setVisible(False)
            self.multi_city_widget.setEnabled(False)
            
            print("‚úÖ DEBUG: UI set to single_location mode - LOCATION WIDGET VISIBLE, MULTI-CITY HIDDEN")
            
        elif analysis_type in ["region", "county"]:
            print(f"üîß DEBUG: Setting UI to {analysis_type} mode - MultiCityWidget MEGJELEN√çT√âSE...")
            
            # === LOCATION WIDGET ELREJT√âSE ===
            self.location_widget.setVisible(False)
            self.location_widget.setEnabled(False)
            
            # === MULTI-CITY WIDGET MEGJELEN√çT√âSE + MODE BE√ÅLL√çT√ÅSA ===
            self.multi_city_widget.setVisible(True)
            self.multi_city_widget.setEnabled(True)
            self.multi_city_widget.show()
            
            # üèôÔ∏è Analysis mode be√°ll√≠t√°sa a MultiCityWidget-en
            self.multi_city_widget.set_analysis_mode(analysis_type)
            
            print(f"‚úÖ DEBUG: UI set to {analysis_type} mode - MULTI-CITY WIDGET VISIBLE ({analysis_type} mode), LOCATION HIDDEN")
        
        # Query control button text friss√≠t√©se
        if hasattr(self.query_control_widget, 'update_for_analysis_type'):
            self.query_control_widget.update_for_analysis_type(analysis_type)
        
        # Widget refresh k√©sleltetett trigger (Qt event loop miatt)
        QTimer.singleShot(100, self._delayed_widget_refresh)
    
    def _delayed_widget_refresh(self) -> None:
        """
        üîß K√©sleltetett widget refresh - Qt event loop ut√°n + MULTI-CITY.
        """
        try:
            analysis_type = self.analysis_type_widget.get_current_type()
            
            if analysis_type == "single_location":
                # LocationWidget explicit refresh
                if hasattr(self.location_widget, 'location_selector'):
                    self.location_widget.location_selector.setVisible(True)
                    self.location_widget.location_selector.setEnabled(True)
                
                # üö® FINAL VISIBILITY GUARANTEE
                self.location_widget.setVisible(True)
                self.location_widget.show()
                
                print("üîß DEBUG: Delayed widget refresh completed for single_location - LocationWidget VISIBLE")
            
            elif analysis_type in ["region", "county"]:
                # üèôÔ∏è MultiCityWidget explicit refresh
                self.multi_city_widget.setVisible(True)
                self.multi_city_widget.setEnabled(True)
                self.multi_city_widget.show()
                
                print(f"üîß DEBUG: Delayed widget refresh completed for {analysis_type} - MultiCityWidget VISIBLE")
            
        except Exception as e:
            print(f"‚ö†Ô∏è DEBUG: Error during delayed widget refresh: {e}")
    
    def _update_fetch_button_state_comprehensive(self) -> None:
        """
        üîß ROBUSZTUS: Fetch button √°llapot √∫jra√©rt√©kel√©se - comprehensive validation + MULTI-CITY.
        """
        can_fetch = self._comprehensive_fetch_validation()
        
        # Csak ha nem fetch-el√ºnk √©ppen
        if not self.query_control_widget._is_fetching:
            self.query_control_widget.fetch_button.setEnabled(can_fetch)
        
        print(f"üöÄ DEBUG: Fetch button enabled: {can_fetch} (comprehensive validation + multi-city)")
    
    def _comprehensive_fetch_validation(self) -> bool:
        """
        üîß ROBUSZTUS: Comprehensive fetch valid√°l√°s - minden widget √°llapot ellen≈ërz√©se + MULTI-CITY.
        
        Returns:
            bool: True ha ind√≠that√≥ a fetch
        """
        try:
            # Analysis type check
            analysis_type = self.analysis_type_widget.get_current_type()
            if not analysis_type:
                print("‚ùå DEBUG: No analysis type selected")
                return False
            
            # Location/Multi-city check analysis type szerint
            if analysis_type == "single_location":
                # Single location validation
                location_valid = self.location_widget.is_valid()
                if not location_valid:
                    print("‚ùå DEBUG: Location not valid in single_location mode")
                    return False
                
                # Tov√°bbi location ellen≈ërz√©sek
                location_state = self.location_widget.get_state()
                if not location_state.get("has_location", False):
                    print("‚ùå DEBUG: No location selected in single_location mode")
                    return False
                
                city_data = location_state.get("current_city_data")
                if not city_data or not all(key in city_data for key in ["latitude", "longitude"]):
                    print("‚ùå DEBUG: Invalid city data in single_location mode")
                    return False
                
            elif analysis_type in ["region", "county"]:
                # üèôÔ∏è Multi-city validation
                multi_city_valid = self.multi_city_widget.is_valid()
                if not multi_city_valid:
                    print(f"‚ùå DEBUG: Multi-city selection not valid in {analysis_type} mode")
                    return False
                
                # Tov√°bbi multi-city ellen≈ërz√©sek
                multi_city_state = self.multi_city_widget.get_state()
                if multi_city_state.get("selection_count", 0) == 0:
                    print(f"‚ùå DEBUG: No {analysis_type} selected in multi-city mode")
                    return False
                
                print(f"‚úÖ DEBUG: Multi-city validation passed for {analysis_type}")
            
            # Date range check
            date_valid = self.date_range_widget.is_valid()
            if not date_valid:
                print("‚ùå DEBUG: Date range not valid")
                return False
            
            # API settings check
            api_valid = self.api_settings_widget.is_valid()
            if not api_valid:
                print("‚ùå DEBUG: API settings not valid")
                return False
            
            # Provider check
            provider_valid = self.provider_widget.is_valid()
            if not provider_valid:
                print("‚ùå DEBUG: Provider not valid")
                return False
            
            # Fetching state check
            not_fetching = not self.query_control_widget._is_fetching
            if not not_fetching:
                print("‚ùå DEBUG: Fetch already in progress")
                return False
            
            print(f"‚úÖ DEBUG: Comprehensive validation passed for {analysis_type}")
            return True
            
        except Exception as e:
            print(f"‚ùå DEBUG: Error during comprehensive fetch validation: {e}")
            return False
    
    # === ANALYSIS REQUEST BUILDING - CLEAN ARCHITECTURE + MULTI-CITY T√ÅMOGAT√ÅS ===
    
    def _build_analysis_request(self) -> Dict[str, Any]:
        """
        üéØ COMPREHENSIVE ANALYSIS REQUEST - Widget State Aggregation + MULTI-CITY
        
        Ez a CLEAN ARCHITECTURE k√∂zponti data aggregation pontja.
        Minden widget state-j√©t √∂sszegy≈±jti egy comprehensive request-be.
        
        Returns:
            Teljes analysis request dict minden param√©terrel
        """
        return {
            # Analysis type √©s location/multi-city
            **self._get_analysis_params(),
            
            # Date range
            **self._get_date_params(),
            
            # Provider √©s API settings
            **self._get_api_params(),
            
            # Meta inform√°ci√≥k
            "timestamp": datetime.now().isoformat(),
            "request_id": f"req_{int(datetime.now().timestamp())}",
            "widget_states": self._get_all_widget_states()
        }
    
    def _get_analysis_params(self) -> Dict[str, Any]:
        """Analysis √©s location/multi-city param√©terek + MULTI-CITY T√ÅMOGAT√ÅS."""
        analysis_type = self.analysis_type_widget.get_current_type()
        
        params = {
            "analysis_type": analysis_type
        }
        
        if analysis_type == "single_location":
            # Single location parameterek
            location_state = self.location_widget.get_state()
            if location_state["has_location"]:
                city_data = location_state["current_city_data"]
                params.update({
                    "latitude": city_data["latitude"],
                    "longitude": city_data["longitude"],
                    "location_name": city_data["name"],
                    "location_data": city_data
                })
        
        elif analysis_type in ["region", "county"]:
            # üö® FIX: Analysis type konverzi√≥ AppController kompatibilit√°shoz
            if analysis_type == "region":
                converted_analysis_type = "multi_city"
            else:  # county
                converted_analysis_type = "county_analysis"
            
            # üèôÔ∏è Multi-city param√©terek
            multi_city_state = self.multi_city_widget.get_state()
            selected_cities = self.multi_city_widget.get_selected_cities()
            
            # üö® FIX: AppController kompatibilis r√©gi√≥/megye n√©v mez≈ëk
            current_selection = multi_city_state["current_selection"]
            if analysis_type == "region":
                region_name = current_selection
                county_name = None
            else:  # county
                region_name = None
                county_name = current_selection
            
            params.update({
                "analysis_type": converted_analysis_type,  # üö® FIX: Konvert√°lt analysis_type
                "multi_city_mode": True,
                "region_or_county": analysis_type,  # Eredeti t√≠pus meg≈ërz√©se
                # üö® FIX: AppController v√°rt mez≈ëk
                "region_name": region_name,
                "county_name": county_name,
                "multi_city_selection": {
                    "mode": multi_city_state["mode"],
                    "selected": multi_city_state["current_selection"],
                    "count": multi_city_state["selection_count"]
                },
                "selected_cities": selected_cities,
                "city_count": len(selected_cities)
            })
            
            print(f"üèôÔ∏è DEBUG: Multi-city analysis request - {len(selected_cities)} cities selected")
            print(f"üö® DEBUG: Analysis type converted: {analysis_type} ‚Üí {converted_analysis_type}")
        
        return params
    
    def _get_date_params(self) -> Dict[str, Any]:
        """
        üö® KRITIKUS FIX: Date range param√©terek AppController kompatibilis form√°tumban.
        
        AppController ezt v√°rja:
        "date_range": {
            "start_date": "2024-08-13",
            "end_date": "2025-08-13"
        }
        """
        date_state = self.date_range_widget.get_state()
        
        return {
            "date_mode": date_state["date_mode"],
            # üö® FIX: date_range objektum a k√ºl√∂n start_date/end_date helyett
            "date_range": {
                "start_date": date_state["start_date"],
                "end_date": date_state["end_date"]
            },
            "time_range": date_state.get("time_range")
        }
    
    def _get_api_params(self) -> Dict[str, Any]:
        """Provider √©s API param√©terek."""
        provider_state = self.provider_widget.get_state()
        api_state = self.api_settings_widget.get_state()
        
        return {
            "provider": provider_state["current_provider"],
            "api_settings": api_state["settings"],
            "provider_preferences": provider_state.get("provider_preferences", {})
        }
    
    def _validate_analysis_request(self, request: Dict[str, Any]) -> bool:
        """
        üö® KRITIKUS FIX: Analysis request valid√°l√°sa + MULTI-CITY - JAV√çTOTT VALIDATION LOGIC.
        
        A f≈ë hiba helye volt itt! A validation a location_data objektum alatt keresi a lat/lon kulcsokat.
        """
        # Analysis type check
        if "analysis_type" not in request:
            print("‚ùå DEBUG: Missing analysis_type in request")
            return False
        
        analysis_type = request["analysis_type"]
        
        # üö® FIX: Konvert√°lt analysis type valid√°l√°s
        valid_types = ["single_location", "multi_city", "county_analysis"]
        if analysis_type not in valid_types:
            print(f"‚ùå DEBUG: Invalid analysis type: {analysis_type}")
            return False
        
        # üö® KRITIKUS FIX: Single location validation - location_data objektum alatt keresi lat/lon
        if analysis_type == "single_location":
            if "location_data" not in request:
                print("‚ùå DEBUG: Missing location_data in request")
                return False
            location_data = request["location_data"]
            if not all(key in location_data for key in ["latitude", "longitude"]):
                print(f"‚ùå DEBUG: Missing lat/lon in location_data: {list(location_data.keys())}")
                return False
            print("‚úÖ DEBUG: Single location validation passed - location_data structure valid")
        
        # üèôÔ∏è Multi-city validation (mind a k√©t t√≠pusra)
        elif analysis_type in ["multi_city", "county_analysis"]:
            if "multi_city_mode" not in request or not request["multi_city_mode"]:
                print("‚ùå DEBUG: Missing multi_city_mode in request")
                return False
            
            if "selected_cities" not in request or len(request["selected_cities"]) == 0:
                print("‚ùå DEBUG: No selected_cities in multi-city request")
                return False
            
            print(f"‚úÖ DEBUG: Multi-city validation passed - {len(request['selected_cities'])} cities")
        
        # Date validation - üö® FIX: date_range objektum ellen≈ërz√©se
        if "date_range" not in request:
            print("‚ùå DEBUG: Missing date_range in request")
            return False
            
        date_range = request["date_range"]
        if not all(key in date_range for key in ["start_date", "end_date"]):
            print(f"‚ùå DEBUG: Missing start_date/end_date in date_range: {list(date_range.keys())}")
            return False
        
        # API validation
        if "provider" not in request or "api_settings" not in request:
            print("‚ùå DEBUG: Missing provider or api_settings in request")
            return False
        
        print(f"‚úÖ DEBUG: Analysis request validation passed for {analysis_type}")
        return True
    
    # === PUBLIC API - STATE MANAGEMENT + MULTI-CITY ===
    
    def get_current_state(self) -> Dict[str, Any]:
        """Teljes panel √°llapot lek√©rdez√©se + MULTI-CITY."""
        return {
            "analysis_type": self.analysis_type_widget.get_state(),
            "location": self.location_widget.get_state(),
            "multi_city": self.multi_city_widget.get_state(),  # üèôÔ∏è √öJ
            "date_range": self.date_range_widget.get_state(),
            "provider": self.provider_widget.get_state(),
            "api_settings": self.api_settings_widget.get_state(),
            "query_control": self.query_control_widget.get_state()
        }
    
    def _get_all_widget_states(self) -> Dict[str, Any]:
        """√ñsszes widget state lek√©rdez√©se (internal) + MULTI-CITY."""
        return self.get_current_state()
    
    def set_panel_state(self, state: Dict[str, Any]) -> bool:
        """Teljes panel √°llapot be√°ll√≠t√°sa + MULTI-CITY."""
        success = True
        
        # Widget states be√°ll√≠t√°sa egyenk√©nt
        if "analysis_type" in state:
            success &= self.analysis_type_widget.set_state(state["analysis_type"])
        
        if "location" in state:
            success &= self.location_widget.set_state(state["location"])
        
        # üèôÔ∏è Multi-city state be√°ll√≠t√°sa
        if "multi_city" in state:
            success &= self.multi_city_widget.set_state(state["multi_city"])
        
        if "date_range" in state:
            success &= self.date_range_widget.set_state(state["date_range"])
        
        if "provider" in state:
            success &= self.provider_widget.set_state(state["provider"])
        
        if "api_settings" in state:
            success &= self.api_settings_widget.set_state(state["api_settings"])
        
        # UI friss√≠t√©se
        if success:
            analysis_type = self.analysis_type_widget.get_current_type()
            self._update_ui_for_analysis_type_fixed(analysis_type)
            self._update_fetch_button_state_comprehensive()
        
        return success
    
    def is_valid(self) -> bool:
        """Panel valid√°l√°sa - minden widget valid kell legyen + MULTI-CITY."""
        analysis_type = self.analysis_type_widget.get_current_type()
        
        # Base validation
        valid = (
            self.analysis_type_widget.is_valid() and
            self.date_range_widget.is_valid() and
            self.provider_widget.is_valid() and
            self.api_settings_widget.is_valid()
        )
        
        # Location/Multi-city validation analysis type szerint
        if analysis_type == "single_location":
            valid &= self.location_widget.is_valid()
        elif analysis_type in ["region", "county"]:
            valid &= self.multi_city_widget.is_valid()  # üèôÔ∏è √öJ
        
        return valid
    
    def set_enabled(self, enabled: bool) -> None:
        """Teljes panel enged√©lyez√©se/letilt√°sa + MULTI-CITY."""
        self.analysis_type_widget.set_enabled(enabled)
        self.location_widget.set_enabled(enabled)
        self.multi_city_widget.set_enabled(enabled)  # üèôÔ∏è √öJ
        self.date_range_widget.set_enabled(enabled)
        self.provider_widget.set_enabled(enabled)
        self.api_settings_widget.set_enabled(enabled)
        # QueryControlWidget saj√°t maga kezeli az enabled st√°tuszt
        
        print(f"üéØ ControlPanel enabled state: {enabled} (+ MultiCityWidget)")
    
    # === EXTERNAL SIGNAL HANDLERS (UNCHANGED) ===
    
    def _auto_reset_fetch_state(self) -> None:
        """üîß AUTO-RESET: Fetch state reset timeout eset√©re."""
        if self.query_control_widget._is_fetching:
            print("üîß DEBUG: Auto-resetting fetch state after timeout")
            self.query_control_widget.set_fetching_state(False)
            self.query_control_widget.set_progress_text("‚è∞ Timeout - pr√≥b√°lja √∫jra")
            self._update_fetch_button_state_comprehensive()
    
    def on_weather_data_completed(self) -> None:
        """Weather data lek√©rdez√©s befejez√©se k√ºls≈ë jelz√©s alapj√°n."""
        self.query_control_widget.set_fetching_state(False)
        self.query_control_widget.set_progress_text("‚úÖ Adatok sikeresen lek√©rdezve")
        self._update_fetch_button_state_comprehensive()
        
        print("‚úÖ Weather data completed - UI updated")
    
    def on_controller_error(self, error_message: str) -> None:
        """Hiba kezel√©se k√ºls≈ë jelz√©s alapj√°n."""
        self.query_control_widget.set_fetching_state(False)
        self.query_control_widget.set_progress_text(f"‚ùå Hiba: {error_message}")
        self._update_fetch_button_state_comprehensive()
        
        self.local_error_occurred.emit(error_message)
        
        print(f"‚ùå Controller error: {error_message}")
    
    def update_progress(self, worker_type: str, progress: int) -> None:
        """Progress friss√≠t√©se k√ºls≈ë jelz√©s alapj√°n."""
        if 0 <= progress <= 100:
            self.query_control_widget.set_progress_value(progress)
            self.query_control_widget.set_progress_text(f"‚è≥ {worker_type}: {progress}%")
        
        if progress >= 100:
            self.query_control_widget.set_progress_text("‚úÖ Befejezve")
    
    def update_status_from_controller(self, message: str) -> None:
        """Status friss√≠t√©se k√ºls≈ë controller-b≈ël."""
        self.query_control_widget.set_progress_text(message)
        print(f"üìä Status update: {message}")
    
    # === GEOCODING COMPATIBILITY HANDLERS (UNCHANGED) ===
    
    def _on_geocoding_completed(self, results: List[Dict[str, Any]]) -> None:
        """Geocoding eredm√©nyek fogad√°sa - LocationWidget-re tov√°bb√≠t√°s."""
        if hasattr(self.location_widget, 'update_search_results'):
            self.location_widget.update_search_results(results)
        
        print(f"üîç Geocoding completed: {len(results)} results")
    
    def _on_geocoding_error(self, error_message: str) -> None:
        """Geocoding hiba fogad√°sa."""
        self.local_error_occurred.emit(f"Keres√©si hiba: {error_message}")
        print(f"‚ùå Geocoding error: {error_message}")
    
    # === LEGACY COMPATIBILITY API (MINIM√ÅLIS) ===
    
    def get_selected_city_data(self) -> Optional[Dict[str, Any]]:
        """Legacy: Kiv√°lasztott v√°ros adatok."""
        return self.location_widget.get_current_city_data()
    
    def get_date_range(self) -> tuple[str, str]:
        """Legacy: D√°tum tartom√°ny."""
        return self.date_range_widget.get_date_range()
    
    def get_analysis_type(self) -> str:
        """Legacy: Analysis type."""
        return self.analysis_type_widget.get_current_type()
    
    def get_provider(self) -> str:
        """Legacy: Provider."""
        return self.provider_widget.get_current_provider()
    
    def is_fetch_in_progress(self) -> bool:
        """Legacy: Fetch progress check."""
        return self.query_control_widget._is_fetching
    
    # üèôÔ∏è √öJ LEGACY API: Multi-city support
    def get_selected_multi_city_data(self) -> Dict[str, Any]:
        """√öJ: Multi-city selection adatok."""
        return self.multi_city_widget.get_state()
    
    def get_selected_cities(self) -> List[Dict[str, Any]]:
        """√öJ: Kiv√°lasztott v√°rosok list√°ja multi-city m√≥dban."""
        return self.multi_city_widget.get_selected_cities()
    
    def refresh_ui_state(self) -> None:
        """UI √°llapot teljes friss√≠t√©se + MULTI-CITY."""
        analysis_type = self.analysis_type_widget.get_current_type()
        self._update_ui_for_analysis_type_fixed(analysis_type)
        self._update_fetch_button_state_comprehensive()
        self.provider_widget.refresh_usage_display()
        
        print("üîÑ ControlPanel UI state refreshed + MultiCityWidget")
    
    def force_fetch_button_update(self) -> None:
        """Fetch button √°llapot k√©nyszer√≠tett friss√≠t√©se."""
        self._update_fetch_button_state_comprehensive()
    
    # === CLEANUP ===
    
    def cleanup(self) -> None:
        """ControlPanel cleanup - widget cleanup-ok h√≠v√°sa + MULTI-CITY."""
        # Provider widget cleanup (timer le√°ll√≠t√°sa)
        if hasattr(self.provider_widget, 'cleanup'):
            self.provider_widget.cleanup()
        
        # üèôÔ∏è Multi-city widget cleanup (ha van)
        if hasattr(self.multi_city_widget, 'cleanup'):
            self.multi_city_widget.cleanup()
        
        print("üßπ ControlPanel cleanup completed + MultiCityWidget")
    
    def __del__(self):
        """Destruktor."""
        try:
            self.cleanup()
        except:
            pass